"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./src/app/services/returns-processor.js":
/*!***********************************************!*\
  !*** ./src/app/services/returns-processor.js ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   processReturnsWithRule: () => (/* binding */ processReturnsWithRule)\n/* harmony export */ });\n/* harmony import */ var _rule_execution_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rule-execution-engine */ \"(app-pages-browser)/./src/app/services/rule-execution-engine.js\");\n/* harmony import */ var _api_returns_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/returns/data */ \"(app-pages-browser)/./src/app/api/returns/data.js\");\n// app/services/returns-processor.js\n\n\n/**\n * Processes all returns through the rule engine and generates updated statistics\n * @param {Object} ruleDefinition - The exported rule definition JSON\n * @returns {Object} Updated statistics and categorized returns\n */ async function processReturnsWithRule(ruleDefinition) {\n    // Get all recent returns\n    const returns = await (0,_api_returns_data__WEBPACK_IMPORTED_MODULE_1__.getRecentReturns)();\n    const baseStatistics = await (0,_api_returns_data__WEBPACK_IMPORTED_MODULE_1__.getReturnStatistics)();\n    // Process each return through the rule engine\n    const processedReturns = returns.map((returnItem)=>{\n        var _returnItem_items__condition, _returnItem_items__condition1;\n        // Format the return data in the structure expected by the rule engine\n        const returnData = {\n            id: returnItem.id,\n            customerId: returnItem.customerId,\n            customerName: returnItem.customerName,\n            returnFrequency: returnItem.returnFrequency || 'Normal',\n            purchaseDate: returnItem.datePurchased,\n            returnDate: returnItem.dateReturned,\n            itemCondition: ((_returnItem_items__condition = returnItem.items[0].condition) === null || _returnItem_items__condition === void 0 ? void 0 : _returnItem_items__condition.toLowerCase().includes('new')) ? 'unused' : 'used',\n            originalPackaging: ((_returnItem_items__condition1 = returnItem.items[0].condition) === null || _returnItem_items__condition1 === void 0 ? void 0 : _returnItem_items__condition1.toLowerCase().includes('tag')) ? true : false,\n            reason: returnItem.items[0].reason,\n            reasonDetails: returnItem.items[0].reasonDetails,\n            customerReturnsCount: returnItem.returnFrequency === 'High' ? 6 : 2,\n            orderValue: returnItem.items.reduce((total, item)=>total + item.price * item.quantity, 0),\n            itemsCount: returnItem.items.length,\n            categories: [\n                ...new Set(returnItem.items.map((item)=>item.category))\n            ]\n        };\n        // Execute the rule on this return\n        try {\n            const result = (0,_rule_execution_engine__WEBPACK_IMPORTED_MODULE_0__.executeRule)(ruleDefinition, returnData);\n            // Combine original return data with rule processing result\n            return {\n                ...returnItem,\n                ruleProcessingResult: result.result,\n                executionPath: result.executionPath,\n                autoProcessed: result.isComplete,\n                // Update the return status and next actions based on rule result\n                status: mapRuleResultToStatus(result.result, returnItem.status),\n                nextAction: mapRuleResultToNextAction(result.result, returnItem.nextAction, returnItem)\n            };\n        } catch (error) {\n            console.error(\"Error processing return \".concat(returnItem.id, \":\"), error);\n            return {\n                ...returnItem,\n                ruleProcessingResult: 'ERROR',\n                executionPath: [],\n                autoProcessed: false\n            };\n        }\n    });\n    // Generate updated statistics based on rule processing\n    const updatedStatistics = generateUpdatedStatistics(baseStatistics, processedReturns);\n    return {\n        processedReturns,\n        statistics: updatedStatistics,\n        insights: generateInsightsFromProcessing(processedReturns, updatedStatistics)\n    };\n}\n/**\n * Maps a rule result to a return status\n */ function mapRuleResultToStatus(ruleResult, currentStatus) {\n    switch(ruleResult){\n        case 'APPROVED':\n            return 'Processed';\n        case 'REJECTED':\n            return 'Rejected';\n        case 'MANUAL_REVIEW':\n            return 'Under Review';\n        default:\n            return currentStatus;\n    }\n}\n/**\n * Maps a rule result to a next action\n */ /**\n * Maps a rule result to a next action\n */ function mapRuleResultToNextAction(ruleResult, currentNextAction, returnItem) {\n    if (ruleResult.startsWith('OUTCOME_')) {\n        return ruleResult.replace('OUTCOME_', '');\n    }\n    switch(ruleResult){\n        case 'APPROVED':\n            var _returnItem_items__condition;\n            // Check the condition and assign to Resale or Refund Process based on condition\n            if (returnItem && returnItem.items && returnItem.items[0] && (returnItem.items[0].condition === 'Like New' || ((_returnItem_items__condition = returnItem.items[0].condition) === null || _returnItem_items__condition === void 0 ? void 0 : _returnItem_items__condition.includes('New')))) {\n                return 'Resale';\n            }\n            return 'Refund Process';\n        case 'REJECTED':\n            return 'Return to Customer';\n        case 'MANUAL_REVIEW':\n            return 'Quality Assessment';\n        default:\n            return currentNextAction;\n    }\n}\n/**\n * Generates updated statistics based on rule processing results\n */ function generateUpdatedStatistics(baseStatistics, processedReturns) {\n    // Clone the base statistics\n    const statistics = JSON.parse(JSON.stringify(baseStatistics));\n    // Update the statistics based on rule processing\n    statistics.overall.approved = processedReturns.filter((r)=>r.ruleProcessingResult === 'APPROVED' || r.status === 'Processed').length;\n    statistics.overall.denied = processedReturns.filter((r)=>r.ruleProcessingResult === 'REJECTED' || r.status === 'Rejected').length;\n    statistics.overall.pending = processedReturns.filter((r)=>r.ruleProcessingResult === 'MANUAL_REVIEW' || r.status === 'Under Review' || r.status === 'In Process').length;\n    // Calculate the fraud suspected value\n    statistics.overall.fraudSuspected = processedReturns.filter((r)=>r.flag === 'Frequent returner' || r.returnFrequency === 'High' || r.riskScore && r.riskScore > 50).length;\n    // Update by processing status\n    statistics.byProcessingStatus = [\n        {\n            status: \"Refunded\",\n            count: processedReturns.filter((r)=>r.ruleProcessingResult === 'APPROVED' || r.status === 'Processed').length,\n            percentage: Math.round(processedReturns.filter((r)=>r.ruleProcessingResult === 'APPROVED' || r.status === 'Processed').length / processedReturns.length * 100)\n        },\n        {\n            status: \"Resale\",\n            count: processedReturns.filter((r)=>r.nextAction === 'Resale').length,\n            percentage: Math.round(processedReturns.filter((r)=>r.nextAction === 'Resale').length / processedReturns.length * 100)\n        },\n        {\n            status: \"Refurbishment\",\n            count: processedReturns.filter((r)=>r.nextAction === 'Refurbishment').length,\n            percentage: Math.round(processedReturns.filter((r)=>r.nextAction === 'Refurbishment').length / processedReturns.length * 100)\n        },\n        {\n            status: \"Damaged/Write-off\",\n            count: processedReturns.filter((r)=>r.nextAction === 'Quality Assessment').length,\n            percentage: Math.round(processedReturns.filter((r)=>r.nextAction === 'Quality Assessment').length / processedReturns.length * 100)\n        }\n    ];\n    // Calculate auto-processing effectiveness\n    const automaticallyProcessed = processedReturns.filter((r)=>r.autoProcessed).length;\n    statistics.automationMetrics = {\n        automaticallyProcessed,\n        automationRate: Math.round(automaticallyProcessed / processedReturns.length * 100),\n        manualReviewRate: Math.round(processedReturns.filter((r)=>r.ruleProcessingResult === 'MANUAL_REVIEW').length / processedReturns.length * 100),\n        averagePathLength: Math.round(processedReturns.reduce((sum, r)=>{\n            var _r_executionPath;\n            return sum + (((_r_executionPath = r.executionPath) === null || _r_executionPath === void 0 ? void 0 : _r_executionPath.length) || 0);\n        }, 0) / processedReturns.length)\n    };\n    return statistics;\n}\n/**\n * Generates insights based on rule processing\n */ function generateInsightsFromProcessing(processedReturns, statistics) {\n    const insights = [];\n    // Check for high automation opportunities\n    if (statistics.automationMetrics.automationRate < 70) {\n        insights.push({\n            type: \"trend\",\n            title: \"Automation Opportunity\",\n            description: \"Current automation rate is \".concat(statistics.automationMetrics.automationRate, \"%. Consider additional rule refinements.\"),\n            recommendations: [\n                \"Add more condition blocks to your rule flow\",\n                \"Refine existing conditions to be more specific\",\n                \"Create separate rules for different product categories\"\n            ],\n            priority: \"Medium\",\n            potentialImpact: \"Reduced processing costs\"\n        });\n    }\n    // Check for high manual review rate\n    if (statistics.automationMetrics.manualReviewRate > 30) {\n        insights.push({\n            type: \"inventory\",\n            title: \"High Manual Review Rate\",\n            description: \"\".concat(statistics.automationMetrics.manualReviewRate, \"% of returns are being sent for manual review. This increases processing time.\"),\n            recommendations: [\n                \"Refine rule conditions to reduce manual reviews\",\n                \"Add more specific rules for common return scenarios\"\n            ],\n            priority: \"High\",\n            potentialImpact: \"Faster processing, improved customer satisfaction\"\n        });\n    }\n    // Check for return reasons that might need attention\n    const reasonCounts = {};\n    processedReturns.forEach((r)=>{\n        const reason = r.items[0].reason;\n        reasonCounts[reason] = (reasonCounts[reason] || 0) + 1;\n    });\n    const topReason = Object.entries(reasonCounts).sort((a, b)=>b[1] - a[1])[0];\n    if (topReason && topReason[1] > processedReturns.length * 0.3) {\n        insights.push({\n            type: \"customer\",\n            title: 'High Return Rate: \"'.concat(topReason[0], '\"'),\n            description: \"\".concat(Math.round(topReason[1] / processedReturns.length * 100), '% of returns cite \"').concat(topReason[0], '\" as the reason.'),\n            recommendations: [\n                \"Review product descriptions and sizing information\",\n                \"Consider adjusting product design or features\",\n                \"Add more detailed product information to reduce expectation mismatch\"\n            ],\n            priority: \"High\",\n            potentialImpact: \"Reduced return rate, increased customer satisfaction\"\n        });\n    }\n    // If there are many frequent returners, add an insight\n    const frequentReturners = processedReturns.filter((r)=>r.returnFrequency === 'High' || r.flag === 'Frequent returner').length;\n    if (frequentReturners > processedReturns.length * 0.15) {\n        insights.push({\n            type: \"fraud\",\n            title: \"High Rate of Frequent Returners\",\n            description: \"\".concat(Math.round(frequentReturners / processedReturns.length * 100), \"% of returns are from frequent returners.\"),\n            recommendations: [\n                \"Review current return policy limits\",\n                \"Consider implementing a return fee for excessive returns\",\n                \"Create special rules for handling frequent returners\"\n            ],\n            priority: \"Medium\",\n            potentialImpact: \"Reduced return abuse, better profit margins\"\n        });\n    }\n    return insights;\n} /**\n * Example usage:\n * \n * // Load your exported rule definition JSON\n * import myRuleDefinition from './my_return_policy_rule.json';\n * \n * // Process all returns using this rule\n * const { processedReturns, statistics, insights } = await processReturnsWithRule(myRuleDefinition);\n * \n * // Now you can update your dashboard with this data\n * updateDashboard(processedReturns, statistics, insights);\n */ \n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvc2VydmljZXMvcmV0dXJucy1wcm9jZXNzb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsb0NBQW9DO0FBRWtCO0FBQ3NCO0FBRTVFOzs7O0NBSUMsR0FDTSxlQUFlRyx1QkFBdUJDLGNBQWM7SUFDekQseUJBQXlCO0lBQ3pCLE1BQU1DLFVBQVUsTUFBTUosbUVBQWdCQTtJQUN0QyxNQUFNSyxpQkFBaUIsTUFBTUosc0VBQW1CQTtJQUVoRCw4Q0FBOEM7SUFDOUMsTUFBTUssbUJBQW1CRixRQUFRRyxHQUFHLENBQUNDLENBQUFBO1lBU2xCQSw4QkFDSUE7UUFUckIsc0VBQXNFO1FBQ3RFLE1BQU1DLGFBQWE7WUFDakJDLElBQUlGLFdBQVdFLEVBQUU7WUFDakJDLFlBQVlILFdBQVdHLFVBQVU7WUFDakNDLGNBQWNKLFdBQVdJLFlBQVk7WUFDckNDLGlCQUFpQkwsV0FBV0ssZUFBZSxJQUFJO1lBQy9DQyxjQUFjTixXQUFXTyxhQUFhO1lBQ3RDQyxZQUFZUixXQUFXUyxZQUFZO1lBQ25DQyxlQUFlVixFQUFBQSwrQkFBQUEsV0FBV1csS0FBSyxDQUFDLEVBQUUsQ0FBQ0MsU0FBUyxjQUE3QlosbURBQUFBLDZCQUErQmEsV0FBVyxHQUFHQyxRQUFRLENBQUMsVUFBUyxXQUFXO1lBQ3pGQyxtQkFBbUJmLEVBQUFBLGdDQUFBQSxXQUFXVyxLQUFLLENBQUMsRUFBRSxDQUFDQyxTQUFTLGNBQTdCWixvREFBQUEsOEJBQStCYSxXQUFXLEdBQUdDLFFBQVEsQ0FBQyxVQUFTLE9BQU87WUFDekZFLFFBQVFoQixXQUFXVyxLQUFLLENBQUMsRUFBRSxDQUFDSyxNQUFNO1lBQ2xDQyxlQUFlakIsV0FBV1csS0FBSyxDQUFDLEVBQUUsQ0FBQ00sYUFBYTtZQUNoREMsc0JBQXNCbEIsV0FBV0ssZUFBZSxLQUFLLFNBQVMsSUFBSTtZQUNsRWMsWUFBWW5CLFdBQVdXLEtBQUssQ0FBQ1MsTUFBTSxDQUFDLENBQUNDLE9BQU9D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WkMsTUFBTTtZQUNOQyxPQUFPLHNCQUFtQyxPQUFiTyxTQUFTLENBQUMsRUFBRSxFQUFDO1lBQzFDTixhQUFhLEdBQW1GTSxPQUFoRmpCLEtBQUtDLEtBQUssQ0FBQyxTQUFVLENBQUMsRUFBRSxHQUFHckUsaUJBQWlCNEIsTUFBTSxHQUFJLE1BQUssdUJBQWtDLE9BQWJ5RCxTQUFTLENBQUMsRUFBRSxFQUFDO1lBQzdHTCxpQkFBaUI7Z0JBQ2Y7Z0JBQ0E7Z0JBQ0E7YUFDRDtZQUNEQyxVQUFVO1lBQ1ZDLGlCQUFpQjtRQUNuQjtJQUNGO0lBRUEsdURBQXVEO0lBQ3ZELE1BQU1TLG9CQUFvQjNGLGlCQUFpQjBELE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRXBELGVBQWUsS0FBSyxVQUFVb0QsRUFBRUksSUFBSSxLQUFLLHFCQUFxQm5DLE1BQU07SUFDN0gsSUFBSStELG9CQUFvQjNGLGlCQUFpQjRCLE1BQU0sR0FBRyxNQUFNO1FBQ3REa0IsU0FBUzhCLElBQUksQ0FBQztZQUNaQyxNQUFNO1lBQ05DLE9BQU87WUFDUEMsYUFBYSxHQUFtRSxPQUFoRVgsS0FBS0MsS0FBSyxDQUFDLG9CQUFxQnJFLGlCQUFpQjRCLE1BQU0sR0FBSSxNQUFLO1lBQ2hGb0QsaUJBQWlCO2dCQUNmO2dCQUNBO2dCQUNBO2FBQ0Q7WUFDREMsVUFBVTtZQUNWQyxpQkFBaUI7UUFDbkI7SUFDRjtJQUVBLE9BQU9wQztBQUNULEVBRUE7Ozs7Ozs7Ozs7O0NBV0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9seHloYW4vR29vZ2xlIHggSGFjayBUaGUgRnV0dXJlL215LW5leHRqcy1hcHAvc3JjL2FwcC9zZXJ2aWNlcy9yZXR1cm5zLXByb2Nlc3Nvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBhcHAvc2VydmljZXMvcmV0dXJucy1wcm9jZXNzb3IuanNcblxuaW1wb3J0IHsgZXhlY3V0ZVJ1bGUgfSBmcm9tICcuL3J1bGUtZXhlY3V0aW9uLWVuZ2luZSc7XG5pbXBvcnQgeyBnZXRSZWNlbnRSZXR1cm5zLCBnZXRSZXR1cm5TdGF0aXN0aWNzIH0gZnJvbSAnLi4vYXBpL3JldHVybnMvZGF0YSc7XG5cbi8qKlxuICogUHJvY2Vzc2VzIGFsbCByZXR1cm5zIHRocm91Z2ggdGhlIHJ1bGUgZW5naW5lIGFuZCBnZW5lcmF0ZXMgdXBkYXRlZCBzdGF0aXN0aWNzXG4gKiBAcGFyYW0ge09iamVjdH0gcnVsZURlZmluaXRpb24gLSBUaGUgZXhwb3J0ZWQgcnVsZSBkZWZpbml0aW9uIEpTT05cbiAqIEByZXR1cm5zIHtPYmplY3R9IFVwZGF0ZWQgc3RhdGlzdGljcyBhbmQgY2F0ZWdvcml6ZWQgcmV0dXJuc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1JldHVybnNXaXRoUnVsZShydWxlRGVmaW5pdGlvbikge1xuICAvLyBHZXQgYWxsIHJlY2VudCByZXR1cm5zXG4gIGNvbnN0IHJldHVybnMgPSBhd2FpdCBnZXRSZWNlbnRSZXR1cm5zKCk7XG4gIGNvbnN0IGJhc2VTdGF0aXN0aWNzID0gYXdhaXQgZ2V0UmV0dXJuU3RhdGlzdGljcygpO1xuICBcbiAgLy8gUHJvY2VzcyBlYWNoIHJldHVybiB0aHJvdWdoIHRoZSBydWxlIGVuZ2luZVxuICBjb25zdCBwcm9jZXNzZWRSZXR1cm5zID0gcmV0dXJucy5tYXAocmV0dXJuSXRlbSA9PiB7XG4gICAgLy8gRm9ybWF0IHRoZSByZXR1cm4gZGF0YSBpbiB0aGUgc3RydWN0dXJlIGV4cGVjdGVkIGJ5IHRoZSBydWxlIGVuZ2luZVxuICAgIGNvbnN0IHJldHVybkRhdGEgPSB7XG4gICAgICBpZDogcmV0dXJuSXRlbS5pZCxcbiAgICAgIGN1c3RvbWVySWQ6IHJldHVybkl0ZW0uY3VzdG9tZXJJZCxcbiAgICAgIGN1c3RvbWVyTmFtZTogcmV0dXJuSXRlbS5jdXN0b21lck5hbWUsXG4gICAgICByZXR1cm5GcmVxdWVuY3k6IHJldHVybkl0ZW0ucmV0dXJuRnJlcXVlbmN5IHx8ICdOb3JtYWwnLFxuICAgICAgcHVyY2hhc2VEYXRlOiByZXR1cm5JdGVtLmRhdGVQdXJjaGFzZWQsXG4gICAgICByZXR1cm5EYXRlOiByZXR1cm5JdGVtLmRhdGVSZXR1cm5lZCxcbiAgICAgIGl0ZW1Db25kaXRpb246IHJldHVybkl0ZW0uaXRlbXNbMF0uY29uZGl0aW9uPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCduZXcnKSA/ICd1bnVzZWQnIDogJ3VzZWQnLFxuICAgICAgb3JpZ2luYWxQYWNrYWdpbmc6IHJldHVybkl0ZW0uaXRlbXNbMF0uY29uZGl0aW9uPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd0YWcnKSA/IHRydWUgOiBmYWxzZSxcbiAgICAgIHJlYXNvbjogcmV0dXJuSXRlbS5pdGVtc1swXS5yZWFzb24sXG4gICAgICByZWFzb25EZXRhaWxzOiByZXR1cm5JdGVtLml0ZW1zWzBdLnJlYXNvbkRldGFpbHMsXG4gICAgICBjdXN0b21lclJldHVybnNDb3VudDogcmV0dXJuSXRlbS5yZXR1cm5GcmVxdWVuY3kgPT09ICdIaWdoJyA/IDYgOiAyLCAvLyBFeGFtcGxlIGxvZ2ljXG4gICAgICBvcmRlclZhbHVlOiByZXR1cm5JdGVtLml0ZW1zLnJlZHVjZSgodG90YWwsIGl0ZW0pID0+IHRvdGFsICsgKGl0ZW0ucHJpY2UgKiBpdGVtLnF1YW50aXR5KSwgMCksXG4gICAgICBpdGVtc0NvdW50OiByZXR1cm5JdGVtLml0ZW1zLmxlbmd0aCxcbiAgICAgIGNhdGVnb3JpZXM6IFsuLi5uZXcgU2V0KHJldHVybkl0ZW0uaXRlbXMubWFwKGl0ZW0gPT4gaXRlbS5jYXRlZ29yeSkpXVxuICAgIH07XG4gICAgXG4gICAgLy8gRXhlY3V0ZSB0aGUgcnVsZSBvbiB0aGlzIHJldHVyblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBleGVjdXRlUnVsZShydWxlRGVmaW5pdGlvbiwgcmV0dXJuRGF0YSk7XG4gICAgICBcbiAgICAgIC8vIENvbWJpbmUgb3JpZ2luYWwgcmV0dXJuIGRhdGEgd2l0aCBydWxlIHByb2Nlc3NpbmcgcmVzdWx0XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXR1cm5JdGVtLFxuICAgICAgICBydWxlUHJvY2Vzc2luZ1Jlc3VsdDogcmVzdWx0LnJlc3VsdCxcbiAgICAgICAgZXhlY3V0aW9uUGF0aDogcmVzdWx0LmV4ZWN1dGlvblBhdGgsXG4gICAgICAgIGF1dG9Qcm9jZXNzZWQ6IHJlc3VsdC5pc0NvbXBsZXRlLFxuICAgICAgICAvLyBVcGRhdGUgdGhlIHJldHVybiBzdGF0dXMgYW5kIG5leHQgYWN0aW9ucyBiYXNlZCBvbiBydWxlIHJlc3VsdFxuICAgICAgICBzdGF0dXM6IG1hcFJ1bGVSZXN1bHRUb1N0YXR1cyhyZXN1bHQucmVzdWx0LCByZXR1cm5JdGVtLnN0YXR1cyksXG4gICAgICAgIG5leHRBY3Rpb246IG1hcFJ1bGVSZXN1bHRUb05leHRBY3Rpb24ocmVzdWx0LnJlc3VsdCwgcmV0dXJuSXRlbS5uZXh0QWN0aW9uLCByZXR1cm5JdGVtKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyByZXR1cm4gJHtyZXR1cm5JdGVtLmlkfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXR1cm5JdGVtLFxuICAgICAgICBydWxlUHJvY2Vzc2luZ1Jlc3VsdDogJ0VSUk9SJyxcbiAgICAgICAgZXhlY3V0aW9uUGF0aDogW10sXG4gICAgICAgIGF1dG9Qcm9jZXNzZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIFxuICAvLyBHZW5lcmF0ZSB1cGRhdGVkIHN0YXRpc3RpY3MgYmFzZWQgb24gcnVsZSBwcm9jZXNzaW5nXG4gIGNvbnN0IHVwZGF0ZWRTdGF0aXN0aWNzID0gZ2VuZXJhdGVVcGRhdGVkU3RhdGlzdGljcyhiYXNlU3RhdGlzdGljcywgcHJvY2Vzc2VkUmV0dXJucyk7XG4gIFxuICByZXR1cm4ge1xuICAgIHByb2Nlc3NlZFJldHVybnMsXG4gICAgc3RhdGlzdGljczogdXBkYXRlZFN0YXRpc3RpY3MsXG4gICAgaW5zaWdodHM6IGdlbmVyYXRlSW5zaWdodHNGcm9tUHJvY2Vzc2luZyhwcm9jZXNzZWRSZXR1cm5zLCB1cGRhdGVkU3RhdGlzdGljcylcbiAgfTtcbn1cblxuLyoqXG4gKiBNYXBzIGEgcnVsZSByZXN1bHQgdG8gYSByZXR1cm4gc3RhdHVzXG4gKi9cbmZ1bmN0aW9uIG1hcFJ1bGVSZXN1bHRUb1N0YXR1cyhydWxlUmVzdWx0LCBjdXJyZW50U3RhdHVzKSB7XG4gIHN3aXRjaCAocnVsZVJlc3VsdCkge1xuICAgIGNhc2UgJ0FQUFJPVkVEJzpcbiAgICAgIHJldHVybiAnUHJvY2Vzc2VkJztcbiAgICBjYXNlICdSRUpFQ1RFRCc6XG4gICAgICByZXR1cm4gJ1JlamVjdGVkJztcbiAgICBjYXNlICdNQU5VQUxfUkVWSUVXJzpcbiAgICAgIHJldHVybiAnVW5kZXIgUmV2aWV3JztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGN1cnJlbnRTdGF0dXM7XG4gIH1cbn1cblxuLyoqXG4gKiBNYXBzIGEgcnVsZSByZXN1bHQgdG8gYSBuZXh0IGFjdGlvblxuICovXG4vKipcbiAqIE1hcHMgYSBydWxlIHJlc3VsdCB0byBhIG5leHQgYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIG1hcFJ1bGVSZXN1bHRUb05leHRBY3Rpb24ocnVsZVJlc3VsdCwgY3VycmVudE5leHRBY3Rpb24sIHJldHVybkl0ZW0pIHtcbiAgaWYgKHJ1bGVSZXN1bHQuc3RhcnRzV2l0aCgnT1VUQ09NRV8nKSkge1xuICAgIHJldHVybiBydWxlUmVzdWx0LnJlcGxhY2UoJ09VVENPTUVfJywgJycpO1xuICB9XG4gIFxuICBzd2l0Y2ggKHJ1bGVSZXN1bHQpIHtcbiAgICBjYXNlICdBUFBST1ZFRCc6XG4gICAgICAvLyBDaGVjayB0aGUgY29uZGl0aW9uIGFuZCBhc3NpZ24gdG8gUmVzYWxlIG9yIFJlZnVuZCBQcm9jZXNzIGJhc2VkIG9uIGNvbmRpdGlvblxuICAgICAgaWYgKHJldHVybkl0ZW0gJiYgcmV0dXJuSXRlbS5pdGVtcyAmJiByZXR1cm5JdGVtLml0ZW1zWzBdICYmIFxuICAgICAgICAgIChyZXR1cm5JdGVtLml0ZW1zWzBdLmNvbmRpdGlvbiA9PT0gJ0xpa2UgTmV3JyB8fCBcbiAgICAgICAgICAgcmV0dXJuSXRlbS5pdGVtc1swXS5jb25kaXRpb24/LmluY2x1ZGVzKCdOZXcnKSkpIHtcbiAgICAgICAgcmV0dXJuICdSZXNhbGUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdSZWZ1bmQgUHJvY2Vzcyc7XG4gICAgY2FzZSAnUkVKRUNURUQnOlxuICAgICAgcmV0dXJuICdSZXR1cm4gdG8gQ3VzdG9tZXInO1xuICAgIGNhc2UgJ01BTlVBTF9SRVZJRVcnOlxuICAgICAgcmV0dXJuICdRdWFsaXR5IEFzc2Vzc21lbnQnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY3VycmVudE5leHRBY3Rpb247XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgdXBkYXRlZCBzdGF0aXN0aWNzIGJhc2VkIG9uIHJ1bGUgcHJvY2Vzc2luZyByZXN1bHRzXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVXBkYXRlZFN0YXRpc3RpY3MoYmFzZVN0YXRpc3RpY3MsIHByb2Nlc3NlZFJldHVybnMpIHtcbiAgLy8gQ2xvbmUgdGhlIGJhc2Ugc3RhdGlzdGljc1xuICBjb25zdCBzdGF0aXN0aWNzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShiYXNlU3RhdGlzdGljcykpO1xuICBcbiAgLy8gVXBkYXRlIHRoZSBzdGF0aXN0aWNzIGJhc2VkIG9uIHJ1bGUgcHJvY2Vzc2luZ1xuICBzdGF0aXN0aWNzLm92ZXJhbGwuYXBwcm92ZWQgPSBwcm9jZXNzZWRSZXR1cm5zLmZpbHRlcihyID0+IFxuICAgIHIucnVsZVByb2Nlc3NpbmdSZXN1bHQgPT09ICdBUFBST1ZFRCcgfHwgci5zdGF0dXMgPT09ICdQcm9jZXNzZWQnXG4gICkubGVuZ3RoO1xuICBcbiAgc3RhdGlzdGljcy5vdmVyYWxsLmRlbmllZCA9IHByb2Nlc3NlZFJldHVybnMuZmlsdGVyKHIgPT4gXG4gICAgci5ydWxlUHJvY2Vzc2luZ1Jlc3VsdCA9PT0gJ1JFSkVDVEVEJyB8fCByLnN0YXR1cyA9PT0gJ1JlamVjdGVkJ1xuICApLmxlbmd0aDtcbiAgXG4gIHN0YXRpc3RpY3Mub3ZlcmFsbC5wZW5kaW5nID0gcHJvY2Vzc2VkUmV0dXJucy5maWx0ZXIociA9PiBcbiAgICByLnJ1bGVQcm9jZXNzaW5nUmVzdWx0ID09PSAnTUFOVUFMX1JFVklFVycgfHwgci5zdGF0dXMgPT09ICdVbmRlciBSZXZpZXcnIHx8IHIuc3RhdHVzID09PSAnSW4gUHJvY2VzcydcbiAgKS5sZW5ndGg7XG4gIFxuICAvLyBDYWxjdWxhdGUgdGhlIGZyYXVkIHN1c3BlY3RlZCB2YWx1ZVxuICBzdGF0aXN0aWNzLm92ZXJhbGwuZnJhdWRTdXNwZWN0ZWQgPSBwcm9jZXNzZWRSZXR1cm5zLmZpbHRlcihyID0+IFxuICAgIHIuZmxhZyA9PT0gJ0ZyZXF1ZW50IHJldHVybmVyJyB8fCByLnJldHVybkZyZXF1ZW5jeSA9PT0gJ0hpZ2gnIHx8IChyLnJpc2tTY29yZSAmJiByLnJpc2tTY29yZSA+IDUwKVxuICApLmxlbmd0aDtcbiAgXG4gIC8vIFVwZGF0ZSBieSBwcm9jZXNzaW5nIHN0YXR1c1xuICBzdGF0aXN0aWNzLmJ5UHJvY2Vzc2luZ1N0YXR1cyA9IFtcbiAgICB7XG4gICAgICBzdGF0dXM6IFwiUmVmdW5kZWRcIixcbiAgICAgIGNvdW50OiBwcm9jZXNzZWRSZXR1cm5zLmZpbHRlcihyID0+IHIucnVsZVByb2Nlc3NpbmdSZXN1bHQgPT09ICdBUFBST1ZFRCcgfHwgci5zdGF0dXMgPT09ICdQcm9jZXNzZWQnKS5sZW5ndGgsXG4gICAgICBwZXJjZW50YWdlOiBNYXRoLnJvdW5kKChwcm9jZXNzZWRSZXR1cm5zLmZpbHRlcihyID0+IHIucnVsZVByb2Nlc3NpbmdSZXN1bHQgPT09ICdBUFBST1ZFRCcgfHwgci5zdGF0dXMgPT09ICdQcm9jZXNzZWQnKS5sZW5ndGggLyBwcm9jZXNzZWRSZXR1cm5zLmxlbmd0aCkgKiAxMDApXG4gICAgfSxcbiAgICB7XG4gICAgICBzdGF0dXM6IFwiUmVzYWxlXCIsXG4gICAgICBjb3VudDogcHJvY2Vzc2VkUmV0dXJucy5maWx0ZXIociA9PiByLm5leHRBY3Rpb24gPT09ICdSZXNhbGUnKS5sZW5ndGgsXG4gICAgICBwZXJjZW50YWdlOiBNYXRoLnJvdW5kKChwcm9jZXNzZWRSZXR1cm5zLmZpbHRlcihyID0+IHIubmV4dEFjdGlvbiA9PT0gJ1Jlc2FsZScpLmxlbmd0aCAvIHByb2Nlc3NlZFJldHVybnMubGVuZ3RoKSAqIDEwMClcbiAgICB9LFxuICAgIHtcbiAgICAgIHN0YXR1czogXCJSZWZ1cmJpc2htZW50XCIsXG4gICAgICBjb3VudDogcHJvY2Vzc2VkUmV0dXJucy5maWx0ZXIociA9PiByLm5leHRBY3Rpb24gPT09ICdSZWZ1cmJpc2htZW50JykubGVuZ3RoLFxuICAgICAgcGVyY2VudGFnZTogTWF0aC5yb3VuZCgocHJvY2Vzc2VkUmV0dXJucy5maWx0ZXIociA9PiByLm5leHRBY3Rpb24gPT09ICdSZWZ1cmJpc2htZW50JykubGVuZ3RoIC8gcHJvY2Vzc2VkUmV0dXJucy5sZW5ndGgpICogMTAwKVxuICAgIH0sXG4gICAge1xuICAgICAgc3RhdHVzOiBcIkRhbWFnZWQvV3JpdGUtb2ZmXCIsXG4gICAgICBjb3VudDogcHJvY2Vzc2VkUmV0dXJucy5maWx0ZXIociA9PiByLm5leHRBY3Rpb24gPT09ICdRdWFsaXR5IEFzc2Vzc21lbnQnKS5sZW5ndGgsXG4gICAgICBwZXJjZW50YWdlOiBNYXRoLnJvdW5kKChwcm9jZXNzZWRSZXR1cm5zLmZpbHRlcihyID0+IHIubmV4dEFjdGlvbiA9PT0gJ1F1YWxpdHkgQXNzZXNzbWVudCcpLmxlbmd0aCAvIHByb2Nlc3NlZFJldHVybnMubGVuZ3RoKSAqIDEwMClcbiAgICB9XG4gIF07XG4gIFxuICAvLyBDYWxjdWxhdGUgYXV0by1wcm9jZXNzaW5nIGVmZmVjdGl2ZW5lc3NcbiAgY29uc3QgYXV0b21hdGljYWxseVByb2Nlc3NlZCA9IHByb2Nlc3NlZFJldHVybnMuZmlsdGVyKHIgPT4gci5hdXRvUHJvY2Vzc2VkKS5sZW5ndGg7XG4gIHN0YXRpc3RpY3MuYXV0b21hdGlvbk1ldHJpY3MgPSB7XG4gICAgYXV0b21hdGljYWxseVByb2Nlc3NlZCxcbiAgICBhdXRvbWF0aW9uUmF0ZTogTWF0aC5yb3VuZCgoYXV0b21hdGljYWxseVByb2Nlc3NlZCAvIHByb2Nlc3NlZFJldHVybnMubGVuZ3RoKSAqIDEwMCksXG4gICAgbWFudWFsUmV2aWV3UmF0ZTogTWF0aC5yb3VuZCgocHJvY2Vzc2VkUmV0dXJucy5maWx0ZXIociA9PiByLnJ1bGVQcm9jZXNzaW5nUmVzdWx0ID09PSAnTUFOVUFMX1JFVklFVycpLmxlbmd0aCAvIHByb2Nlc3NlZFJldHVybnMubGVuZ3RoKSAqIDEwMCksXG4gICAgYXZlcmFnZVBhdGhMZW5ndGg6IE1hdGgucm91bmQocHJvY2Vzc2VkUmV0dXJucy5yZWR1Y2UoKHN1bSwgcikgPT4gc3VtICsgKHIuZXhlY3V0aW9uUGF0aD8ubGVuZ3RoIHx8IDApLCAwKSAvIHByb2Nlc3NlZFJldHVybnMubGVuZ3RoKVxuICB9O1xuICBcbiAgcmV0dXJuIHN0YXRpc3RpY3M7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGluc2lnaHRzIGJhc2VkIG9uIHJ1bGUgcHJvY2Vzc2luZ1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUluc2lnaHRzRnJvbVByb2Nlc3NpbmcocHJvY2Vzc2VkUmV0dXJucywgc3RhdGlzdGljcykge1xuICBjb25zdCBpbnNpZ2h0cyA9IFtdO1xuICBcbiAgLy8gQ2hlY2sgZm9yIGhpZ2ggYXV0b21hdGlvbiBvcHBvcnR1bml0aWVzXG4gIGlmIChzdGF0aXN0aWNzLmF1dG9tYXRpb25NZXRyaWNzLmF1dG9tYXRpb25SYXRlIDwgNzApIHtcbiAgICBpbnNpZ2h0cy5wdXNoKHtcbiAgICAgIHR5cGU6IFwidHJlbmRcIixcbiAgICAgIHRpdGxlOiBcIkF1dG9tYXRpb24gT3Bwb3J0dW5pdHlcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBgQ3VycmVudCBhdXRvbWF0aW9uIHJhdGUgaXMgJHtzdGF0aXN0aWNzLmF1dG9tYXRpb25NZXRyaWNzLmF1dG9tYXRpb25SYXRlfSUuIENvbnNpZGVyIGFkZGl0aW9uYWwgcnVsZSByZWZpbmVtZW50cy5gLFxuICAgICAgcmVjb21tZW5kYXRpb25zOiBbXG4gICAgICAgIFwiQWRkIG1vcmUgY29uZGl0aW9uIGJsb2NrcyB0byB5b3VyIHJ1bGUgZmxvd1wiLFxuICAgICAgICBcIlJlZmluZSBleGlzdGluZyBjb25kaXRpb25zIHRvIGJlIG1vcmUgc3BlY2lmaWNcIixcbiAgICAgICAgXCJDcmVhdGUgc2VwYXJhdGUgcnVsZXMgZm9yIGRpZmZlcmVudCBwcm9kdWN0IGNhdGVnb3JpZXNcIlxuICAgICAgXSxcbiAgICAgIHByaW9yaXR5OiBcIk1lZGl1bVwiLFxuICAgICAgcG90ZW50aWFsSW1wYWN0OiBcIlJlZHVjZWQgcHJvY2Vzc2luZyBjb3N0c1wiXG4gICAgfSk7XG4gIH1cbiAgXG4gIC8vIENoZWNrIGZvciBoaWdoIG1hbnVhbCByZXZpZXcgcmF0ZVxuICBpZiAoc3RhdGlzdGljcy5hdXRvbWF0aW9uTWV0cmljcy5tYW51YWxSZXZpZXdSYXRlID4gMzApIHtcbiAgICBpbnNpZ2h0cy5wdXNoKHtcbiAgICAgIHR5cGU6IFwiaW52ZW50b3J5XCIsXG4gICAgICB0aXRsZTogXCJIaWdoIE1hbnVhbCBSZXZpZXcgUmF0ZVwiLFxuICAgICAgZGVzY3JpcHRpb246IGAke3N0YXRpc3RpY3MuYXV0b21hdGlvbk1ldHJpY3MubWFudWFsUmV2aWV3UmF0ZX0lIG9mIHJldHVybnMgYXJlIGJlaW5nIHNlbnQgZm9yIG1hbnVhbCByZXZpZXcuIFRoaXMgaW5jcmVhc2VzIHByb2Nlc3NpbmcgdGltZS5gLFxuICAgICAgcmVjb21tZW5kYXRpb25zOiBbXG4gICAgICAgIFwiUmVmaW5lIHJ1bGUgY29uZGl0aW9ucyB0byByZWR1Y2UgbWFudWFsIHJldmlld3NcIixcbiAgICAgICAgXCJBZGQgbW9yZSBzcGVjaWZpYyBydWxlcyBmb3IgY29tbW9uIHJldHVybiBzY2VuYXJpb3NcIlxuICAgICAgXSxcbiAgICAgIHByaW9yaXR5OiBcIkhpZ2hcIixcbiAgICAgIHBvdGVudGlhbEltcGFjdDogXCJGYXN0ZXIgcHJvY2Vzc2luZywgaW1wcm92ZWQgY3VzdG9tZXIgc2F0aXNmYWN0aW9uXCJcbiAgICB9KTtcbiAgfVxuICBcbiAgLy8gQ2hlY2sgZm9yIHJldHVybiByZWFzb25zIHRoYXQgbWlnaHQgbmVlZCBhdHRlbnRpb25cbiAgY29uc3QgcmVhc29uQ291bnRzID0ge307XG4gIHByb2Nlc3NlZFJldHVybnMuZm9yRWFjaChyID0+IHtcbiAgICBjb25zdCByZWFzb24gPSByLml0ZW1zWzBdLnJlYXNvbjtcbiAgICByZWFzb25Db3VudHNbcmVhc29uXSA9IChyZWFzb25Db3VudHNbcmVhc29uXSB8fCAwKSArIDE7XG4gIH0pO1xuICBcbiAgY29uc3QgdG9wUmVhc29uID0gT2JqZWN0LmVudHJpZXMocmVhc29uQ291bnRzKS5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSlbMF07XG4gIGlmICh0b3BSZWFzb24gJiYgdG9wUmVhc29uWzFdID4gcHJvY2Vzc2VkUmV0dXJucy5sZW5ndGggKiAwLjMpIHtcbiAgICBpbnNpZ2h0cy5wdXNoKHtcbiAgICAgIHR5cGU6IFwiY3VzdG9tZXJcIixcbiAgICAgIHRpdGxlOiBgSGlnaCBSZXR1cm4gUmF0ZTogXCIke3RvcFJlYXNvblswXX1cImAsXG4gICAgICBkZXNjcmlwdGlvbjogYCR7TWF0aC5yb3VuZCgodG9wUmVhc29uWzFdIC8gcHJvY2Vzc2VkUmV0dXJucy5sZW5ndGgpICogMTAwKX0lIG9mIHJldHVybnMgY2l0ZSBcIiR7dG9wUmVhc29uWzBdfVwiIGFzIHRoZSByZWFzb24uYCxcbiAgICAgIHJlY29tbWVuZGF0aW9uczogW1xuICAgICAgICBcIlJldmlldyBwcm9kdWN0IGRlc2NyaXB0aW9ucyBhbmQgc2l6aW5nIGluZm9ybWF0aW9uXCIsXG4gICAgICAgIFwiQ29uc2lkZXIgYWRqdXN0aW5nIHByb2R1Y3QgZGVzaWduIG9yIGZlYXR1cmVzXCIsXG4gICAgICAgIFwiQWRkIG1vcmUgZGV0YWlsZWQgcHJvZHVjdCBpbmZvcm1hdGlvbiB0byByZWR1Y2UgZXhwZWN0YXRpb24gbWlzbWF0Y2hcIlxuICAgICAgXSxcbiAgICAgIHByaW9yaXR5OiBcIkhpZ2hcIixcbiAgICAgIHBvdGVudGlhbEltcGFjdDogXCJSZWR1Y2VkIHJldHVybiByYXRlLCBpbmNyZWFzZWQgY3VzdG9tZXIgc2F0aXNmYWN0aW9uXCJcbiAgICB9KTtcbiAgfVxuICBcbiAgLy8gSWYgdGhlcmUgYXJlIG1hbnkgZnJlcXVlbnQgcmV0dXJuZXJzLCBhZGQgYW4gaW5zaWdodFxuICBjb25zdCBmcmVxdWVudFJldHVybmVycyA9IHByb2Nlc3NlZFJldHVybnMuZmlsdGVyKHIgPT4gci5yZXR1cm5GcmVxdWVuY3kgPT09ICdIaWdoJyB8fCByLmZsYWcgPT09ICdGcmVxdWVudCByZXR1cm5lcicpLmxlbmd0aDtcbiAgaWYgKGZyZXF1ZW50UmV0dXJuZXJzID4gcHJvY2Vzc2VkUmV0dXJucy5sZW5ndGggKiAwLjE1KSB7XG4gICAgaW5zaWdodHMucHVzaCh7XG4gICAgICB0eXBlOiBcImZyYXVkXCIsXG4gICAgICB0aXRsZTogXCJIaWdoIFJhdGUgb2YgRnJlcXVlbnQgUmV0dXJuZXJzXCIsXG4gICAgICBkZXNjcmlwdGlvbjogYCR7TWF0aC5yb3VuZCgoZnJlcXVlbnRSZXR1cm5lcnMgLyBwcm9jZXNzZWRSZXR1cm5zLmxlbmd0aCkgKiAxMDApfSUgb2YgcmV0dXJucyBhcmUgZnJvbSBmcmVxdWVudCByZXR1cm5lcnMuYCxcbiAgICAgIHJlY29tbWVuZGF0aW9uczogW1xuICAgICAgICBcIlJldmlldyBjdXJyZW50IHJldHVybiBwb2xpY3kgbGltaXRzXCIsXG4gICAgICAgIFwiQ29uc2lkZXIgaW1wbGVtZW50aW5nIGEgcmV0dXJuIGZlZSBmb3IgZXhjZXNzaXZlIHJldHVybnNcIixcbiAgICAgICAgXCJDcmVhdGUgc3BlY2lhbCBydWxlcyBmb3IgaGFuZGxpbmcgZnJlcXVlbnQgcmV0dXJuZXJzXCJcbiAgICAgIF0sXG4gICAgICBwcmlvcml0eTogXCJNZWRpdW1cIixcbiAgICAgIHBvdGVudGlhbEltcGFjdDogXCJSZWR1Y2VkIHJldHVybiBhYnVzZSwgYmV0dGVyIHByb2ZpdCBtYXJnaW5zXCJcbiAgICB9KTtcbiAgfVxuICBcbiAgcmV0dXJuIGluc2lnaHRzO1xufVxuXG4vKipcbiAqIEV4YW1wbGUgdXNhZ2U6XG4gKiBcbiAqIC8vIExvYWQgeW91ciBleHBvcnRlZCBydWxlIGRlZmluaXRpb24gSlNPTlxuICogaW1wb3J0IG15UnVsZURlZmluaXRpb24gZnJvbSAnLi9teV9yZXR1cm5fcG9saWN5X3J1bGUuanNvbic7XG4gKiBcbiAqIC8vIFByb2Nlc3MgYWxsIHJldHVybnMgdXNpbmcgdGhpcyBydWxlXG4gKiBjb25zdCB7IHByb2Nlc3NlZFJldHVybnMsIHN0YXRpc3RpY3MsIGluc2lnaHRzIH0gPSBhd2FpdCBwcm9jZXNzUmV0dXJuc1dpdGhSdWxlKG15UnVsZURlZmluaXRpb24pO1xuICogXG4gKiAvLyBOb3cgeW91IGNhbiB1cGRhdGUgeW91ciBkYXNoYm9hcmQgd2l0aCB0aGlzIGRhdGFcbiAqIHVwZGF0ZURhc2hib2FyZChwcm9jZXNzZWRSZXR1cm5zLCBzdGF0aXN0aWNzLCBpbnNpZ2h0cyk7XG4gKi8iXSwibmFtZXMiOlsiZXhlY3V0ZVJ1bGUiLCJnZXRSZWNlbnRSZXR1cm5zIiwiZ2V0UmV0dXJuU3RhdGlzdGljcyIsInByb2Nlc3NSZXR1cm5zV2l0aFJ1bGUiLCJydWxlRGVmaW5pdGlvbiIsInJldHVybnMiLCJiYXNlU3RhdGlzdGljcyIsInByb2Nlc3NlZFJldHVybnMiLCJtYXAiLCJyZXR1cm5JdGVtIiwicmV0dXJuRGF0YSIsImlkIiwiY3VzdG9tZXJJZCIsImN1c3RvbWVyTmFtZSIsInJldHVybkZyZXF1ZW5jeSIsInB1cmNoYXNlRGF0ZSIsImRhdGVQdXJjaGFzZWQiLCJyZXR1cm5EYXRlIiwiZGF0ZVJldHVybmVkIiwiaXRlbUNvbmRpdGlvbiIsIml0ZW1zIiwiY29uZGl0aW9uIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsIm9yaWdpbmFsUGFja2FnaW5nIiwicmVhc29uIiwicmVhc29uRGV0YWlscyIsImN1c3RvbWVyUmV0dXJuc0NvdW50Iiwib3JkZXJWYWx1ZSIsInJlZHVjZSIsInRvdGFsIiwiaXRlbSIsInByaWNlIiwicXVhbnRpdHkiLCJpdGVtc0NvdW50IiwibGVuZ3RoIiwiY2F0ZWdvcmllcyIsIlNldCIsImNhdGVnb3J5IiwicmVzdWx0IiwicnVsZVByb2Nlc3NpbmdSZXN1bHQiLCJleGVjdXRpb25QYXRoIiwiYXV0b1Byb2Nlc3NlZCIsImlzQ29tcGxldGUiLCJzdGF0dXMiLCJtYXBSdWxlUmVzdWx0VG9TdGF0dXMiLCJuZXh0QWN0aW9uIiwibWFwUnVsZVJlc3VsdFRvTmV4dEFjdGlvbiIsImVycm9yIiwiY29uc29sZSIsInVwZGF0ZWRTdGF0aXN0aWNzIiwiZ2VuZXJhdGVVcGRhdGVkU3RhdGlzdGljcyIsInN0YXRpc3RpY3MiLCJpbnNpZ2h0cyIsImdlbmVyYXRlSW5zaWdodHNGcm9tUHJvY2Vzc2luZyIsInJ1bGVSZXN1bHQiLCJjdXJyZW50U3RhdHVzIiwiY3VycmVudE5leHRBY3Rpb24iLCJzdGFydHNXaXRoIiwicmVwbGFjZSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsIm92ZXJhbGwiLCJhcHByb3ZlZCIsImZpbHRlciIsInIiLCJkZW5pZWQiLCJwZW5kaW5nIiwiZnJhdWRTdXNwZWN0ZWQiLCJmbGFnIiwicmlza1Njb3JlIiwiYnlQcm9jZXNzaW5nU3RhdHVzIiwiY291bnQiLCJwZXJjZW50YWdlIiwiTWF0aCIsInJvdW5kIiwiYXV0b21hdGljYWxseVByb2Nlc3NlZCIsImF1dG9tYXRpb25NZXRyaWNzIiwiYXV0b21hdGlvblJhdGUiLCJtYW51YWxSZXZpZXdSYXRlIiwiYXZlcmFnZVBhdGhMZW5ndGgiLCJzdW0iLCJwdXNoIiwidHlwZSIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJyZWNvbW1lbmRhdGlvbnMiLCJwcmlvcml0eSIsInBvdGVudGlhbEltcGFjdCIsInJlYXNvbkNvdW50cyIsImZvckVhY2giLCJ0b3BSZWFzb24iLCJPYmplY3QiLCJlbnRyaWVzIiwic29ydCIsImEiLCJiIiwiZnJlcXVlbnRSZXR1cm5lcnMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/services/returns-processor.js\n"));

/***/ })

});