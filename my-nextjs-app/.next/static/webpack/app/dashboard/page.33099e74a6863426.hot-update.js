"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./src/app/services/returns-processor.js":
/*!***********************************************!*\
  !*** ./src/app/services/returns-processor.js ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   processReturnsWithRule: () => (/* binding */ processReturnsWithRule)\n/* harmony export */ });\n/* harmony import */ var _rule_execution_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rule-execution-engine */ \"(app-pages-browser)/./src/app/services/rule-execution-engine.js\");\n/* harmony import */ var _api_returns_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/returns/data */ \"(app-pages-browser)/./src/app/api/returns/data.js\");\n// app/services/returns-processor.js\n\n\n/**\n * Processes all returns through the rule engine and generates updated statistics\n * @param {Object} ruleDefinition - The exported rule definition JSON\n * @returns {Object} Updated statistics and categorized returns\n */ async function processReturnsWithRule(ruleDefinition) {\n    // Get all recent returns\n    const returns = await (0,_api_returns_data__WEBPACK_IMPORTED_MODULE_1__.getRecentReturns)();\n    const baseStatistics = await (0,_api_returns_data__WEBPACK_IMPORTED_MODULE_1__.getReturnStatistics)();\n    // Process each return through the rule engine\n    const processedReturns = returns.map((returnItem1)=>{\n        var _returnItem_items__condition, _returnItem_items__condition1;\n        // Format the return data in the structure expected by the rule engine\n        const returnData = {\n            id: returnItem1.id,\n            customerId: returnItem1.customerId,\n            customerName: returnItem1.customerName,\n            returnFrequency: returnItem1.returnFrequency || 'Normal',\n            purchaseDate: returnItem1.datePurchased,\n            returnDate: returnItem1.dateReturned,\n            itemCondition: ((_returnItem_items__condition = returnItem1.items[0].condition) === null || _returnItem_items__condition === void 0 ? void 0 : _returnItem_items__condition.toLowerCase().includes('new')) ? 'unused' : 'used',\n            originalPackaging: ((_returnItem_items__condition1 = returnItem1.items[0].condition) === null || _returnItem_items__condition1 === void 0 ? void 0 : _returnItem_items__condition1.toLowerCase().includes('tag')) ? true : false,\n            reason: returnItem1.items[0].reason,\n            reasonDetails: returnItem1.items[0].reasonDetails,\n            customerReturnsCount: returnItem1.returnFrequency === 'High' ? 6 : 2,\n            orderValue: returnItem1.items.reduce((total, item)=>total + item.price * item.quantity, 0),\n            itemsCount: returnItem1.items.length,\n            categories: [\n                ...new Set(returnItem1.items.map((item)=>item.category))\n            ]\n        };\n        // Execute the rule on this return\n        try {\n            const result = (0,_rule_execution_engine__WEBPACK_IMPORTED_MODULE_0__.executeRule)(ruleDefinition, returnData);\n            // Combine original return data with rule processing result\n            return {\n                ...returnItem1,\n                ruleProcessingResult: result.result,\n                executionPath: result.executionPath,\n                autoProcessed: result.isComplete,\n                // Update the return status and next actions based on rule result\n                status: mapRuleResultToStatus(result.result, returnItem1.status),\n                nextAction: mapRuleResultToNextAction(result.result, returnItem1.nextAction)\n            };\n        } catch (error) {\n            console.error(\"Error processing return \".concat(returnItem1.id, \":\"), error);\n            return {\n                ...returnItem1,\n                ruleProcessingResult: 'ERROR',\n                executionPath: [],\n                autoProcessed: false\n            };\n        }\n    });\n    // Generate updated statistics based on rule processing\n    const updatedStatistics = generateUpdatedStatistics(baseStatistics, processedReturns);\n    return {\n        processedReturns,\n        statistics: updatedStatistics,\n        insights: generateInsightsFromProcessing(processedReturns, updatedStatistics)\n    };\n}\n/**\n * Maps a rule result to a return status\n */ function mapRuleResultToStatus(ruleResult, currentStatus) {\n    switch(ruleResult){\n        case 'APPROVED':\n            return 'Processed';\n        case 'REJECTED':\n            return 'Rejected';\n        case 'MANUAL_REVIEW':\n            return 'Under Review';\n        default:\n            return currentStatus;\n    }\n}\n/**\n * Maps a rule result to a next action\n */ function mapRuleResultToNextAction(ruleResult, currentNextAction) {\n    if (ruleResult.startsWith('OUTCOME_')) {\n        return ruleResult.replace('OUTCOME_', '');\n    }\n    switch(ruleResult){\n        case 'APPROVED':\n            var _returnItem_items__condition;\n            // Check the condition and assign to Resale or Refund Process based on condition\n            if (returnItem && returnItem.items && returnItem.items[0] && (returnItem.items[0].condition === 'Like New' || ((_returnItem_items__condition = returnItem.items[0].condition) === null || _returnItem_items__condition === void 0 ? void 0 : _returnItem_items__condition.includes('New')))) {\n                return 'Resale';\n            }\n            return 'Refund Process';\n        case 'REJECTED':\n            return 'Return to Customer';\n        case 'MANUAL_REVIEW':\n            return 'Quality Assessment';\n        default:\n            return currentNextAction;\n    }\n}\n/**\n * Generates updated statistics based on rule processing results\n */ function generateUpdatedStatistics(baseStatistics, processedReturns) {\n    // Clone the base statistics\n    const statistics = JSON.parse(JSON.stringify(baseStatistics));\n    // Update the statistics based on rule processing\n    statistics.overall.approved = processedReturns.filter((r)=>r.ruleProcessingResult === 'APPROVED' || r.status === 'Processed').length;\n    statistics.overall.denied = processedReturns.filter((r)=>r.ruleProcessingResult === 'REJECTED' || r.status === 'Rejected').length;\n    statistics.overall.pending = processedReturns.filter((r)=>r.ruleProcessingResult === 'MANUAL_REVIEW' || r.status === 'Under Review' || r.status === 'In Process').length;\n    // Calculate the fraud suspected value\n    statistics.overall.fraudSuspected = processedReturns.filter((r)=>r.flag === 'Frequent returner' || r.returnFrequency === 'High' || r.riskScore && r.riskScore > 50).length;\n    // Update by processing status\n    statistics.byProcessingStatus = [\n        {\n            status: \"Refunded\",\n            count: processedReturns.filter((r)=>r.ruleProcessingResult === 'APPROVED' || r.status === 'Processed').length,\n            percentage: Math.round(processedReturns.filter((r)=>r.ruleProcessingResult === 'APPROVED' || r.status === 'Processed').length / processedReturns.length * 100)\n        },\n        {\n            status: \"Resale\",\n            count: processedReturns.filter((r)=>r.nextAction === 'Resale').length,\n            percentage: Math.round(processedReturns.filter((r)=>r.nextAction === 'Resale').length / processedReturns.length * 100)\n        },\n        {\n            status: \"Refurbishment\",\n            count: processedReturns.filter((r)=>r.nextAction === 'Refurbishment').length,\n            percentage: Math.round(processedReturns.filter((r)=>r.nextAction === 'Refurbishment').length / processedReturns.length * 100)\n        },\n        {\n            status: \"Damaged/Write-off\",\n            count: processedReturns.filter((r)=>r.nextAction === 'Quality Assessment').length,\n            percentage: Math.round(processedReturns.filter((r)=>r.nextAction === 'Quality Assessment').length / processedReturns.length * 100)\n        }\n    ];\n    // Calculate auto-processing effectiveness\n    const automaticallyProcessed = processedReturns.filter((r)=>r.autoProcessed).length;\n    statistics.automationMetrics = {\n        automaticallyProcessed,\n        automationRate: Math.round(automaticallyProcessed / processedReturns.length * 100),\n        manualReviewRate: Math.round(processedReturns.filter((r)=>r.ruleProcessingResult === 'MANUAL_REVIEW').length / processedReturns.length * 100),\n        averagePathLength: Math.round(processedReturns.reduce((sum, r)=>{\n            var _r_executionPath;\n            return sum + (((_r_executionPath = r.executionPath) === null || _r_executionPath === void 0 ? void 0 : _r_executionPath.length) || 0);\n        }, 0) / processedReturns.length)\n    };\n    return statistics;\n}\n/**\n * Generates insights based on rule processing\n */ function generateInsightsFromProcessing(processedReturns, statistics) {\n    const insights = [];\n    // Check for high automation opportunities\n    if (statistics.automationMetrics.automationRate < 70) {\n        insights.push({\n            type: \"trend\",\n            title: \"Automation Opportunity\",\n            description: \"Current automation rate is \".concat(statistics.automationMetrics.automationRate, \"%. Consider additional rule refinements.\"),\n            recommendations: [\n                \"Add more condition blocks to your rule flow\",\n                \"Refine existing conditions to be more specific\",\n                \"Create separate rules for different product categories\"\n            ],\n            priority: \"Medium\",\n            potentialImpact: \"Reduced processing costs\"\n        });\n    }\n    // Check for high manual review rate\n    if (statistics.automationMetrics.manualReviewRate > 30) {\n        insights.push({\n            type: \"inventory\",\n            title: \"High Manual Review Rate\",\n            description: \"\".concat(statistics.automationMetrics.manualReviewRate, \"% of returns are being sent for manual review. This increases processing time.\"),\n            recommendations: [\n                \"Refine rule conditions to reduce manual reviews\",\n                \"Add more specific rules for common return scenarios\"\n            ],\n            priority: \"High\",\n            potentialImpact: \"Faster processing, improved customer satisfaction\"\n        });\n    }\n    // Check for return reasons that might need attention\n    const reasonCounts = {};\n    processedReturns.forEach((r)=>{\n        const reason = r.items[0].reason;\n        reasonCounts[reason] = (reasonCounts[reason] || 0) + 1;\n    });\n    const topReason = Object.entries(reasonCounts).sort((a, b)=>b[1] - a[1])[0];\n    if (topReason && topReason[1] > processedReturns.length * 0.3) {\n        insights.push({\n            type: \"customer\",\n            title: 'High Return Rate: \"'.concat(topReason[0], '\"'),\n            description: \"\".concat(Math.round(topReason[1] / processedReturns.length * 100), '% of returns cite \"').concat(topReason[0], '\" as the reason.'),\n            recommendations: [\n                \"Review product descriptions and sizing information\",\n                \"Consider adjusting product design or features\",\n                \"Add more detailed product information to reduce expectation mismatch\"\n            ],\n            priority: \"High\",\n            potentialImpact: \"Reduced return rate, increased customer satisfaction\"\n        });\n    }\n    // If there are many frequent returners, add an insight\n    const frequentReturners = processedReturns.filter((r)=>r.returnFrequency === 'High' || r.flag === 'Frequent returner').length;\n    if (frequentReturners > processedReturns.length * 0.15) {\n        insights.push({\n            type: \"fraud\",\n            title: \"High Rate of Frequent Returners\",\n            description: \"\".concat(Math.round(frequentReturners / processedReturns.length * 100), \"% of returns are from frequent returners.\"),\n            recommendations: [\n                \"Review current return policy limits\",\n                \"Consider implementing a return fee for excessive returns\",\n                \"Create special rules for handling frequent returners\"\n            ],\n            priority: \"Medium\",\n            potentialImpact: \"Reduced return abuse, better profit margins\"\n        });\n    }\n    return insights;\n} /**\n * Example usage:\n * \n * // Load your exported rule definition JSON\n * import myRuleDefinition from './my_return_policy_rule.json';\n * \n * // Process all returns using this rule\n * const { processedReturns, statistics, insights } = await processReturnsWithRule(myRuleDefinition);\n * \n * // Now you can update your dashboard with this data\n * updateDashboard(processedReturns, statistics, insights);\n */ \n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvc2VydmljZXMvcmV0dXJucy1wcm9jZXNzb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsb0NBQW9DO0FBRWtCO0FBQ3NCO0FBRTVFOzs7O0NBSUMsR0FDTSxlQUFlRyx1QkFBdUJDLGNBQWM7SUFDekQseUJBQXlCO0lBQ3pCLE1BQU1DLFVBQVUsTUFBTUosbUVBQWdCQTtJQUN0QyxNQUFNSyxpQkFBaUIsTUFBTUosc0VBQW1CQTtJQUVoRCw4Q0FBOEM7SUFDOUMsTUFBTUssbUJBQW1CRixRQUFRRyxHQUFHLENBQUNDLENBQUFBO1lBU2xCQSw4QkFDSUE7UUFUckIsc0VBQXNFO1FBQ3RFLE1BQU1DLGFBQWE7WUFDakJDLElBQUlGLFlBQVdFLEVBQUU7WUFDakJDLFlBQVlILFlBQVdHLFVBQVU7WUFDakNDLGNBQWNKLFlBQVdJLFlBQVk7WUFDckNDLGlCQUFpQkwsWUFBV0ssZUFBZSxJQUFJO1lBQy9DQyxjQUFjTixZQUFXTyxhQUFhO1lBQ3RDQyxZQUFZUixZQUFXUyxZQUFZO1lBQ25DQyxlQUFlVixFQUFBQSwrQkFBQUEsWUFBV1csS0FBSyxDQUFDLEVBQUUsQ0FBQ0MsU0FBUyxjQUE3QlosbURBQUFBLDZCQUErQmEsV0FBVyxHQUFHQyxRQUFRLENBQUMsVUFBUyxXQUFXO1lBQ3pGQyxtQkFBbUJmLEVBQUFBLGdDQUFBQSxZQUFXVyxLQUFLLENBQUMsRUFBRSxDQUFDQyxTQUFTLGNBQTdCWixvREFBQUEsOEJBQStCYSxXQUFXLEdBQUdDLFFBQVEsQ0FBQyxVQUFTLE9BQU87WUFDekZFLFFBQVFoQixZQUFXVyxLQUFLLENBQUMsRUFBRSxDQUFDSyxNQUFNO1lBQ2xDQyxlQUFlakIsWUFBV1csS0FBSyxDQUFDLEVBQUUsQ0FBQ00sYUFBYTtZQUNoREMsc0JBQXNCbEIsWUFBV0ssZUFBZSxLQUFLLFNBQVMsSUFBSTtZQUNsRWMsWUFBWW5CLFlBQVdXLEtBQUssQ0FBQ1MsTUFBTSxDQUFDLENBQUNDLE9BQU9D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U0FBUyxDQUFDLEVBQUUsRUFBQztZQUMxQ04sYUFBYSxHQUFtRk0sT0FBaEZqQixLQUFLQyxLQUFLLENBQUMsU0FBVSxDQUFDLEVBQUUsR0FBR3JFLGlCQUFpQjRCLE1BQU0sR0FBSSxNQUFLLHVCQUFrQyxPQUFieUQsU0FBUyxDQUFDLEVBQUUsRUFBQztZQUM3R0wsaUJBQWlCO2dCQUNmO2dCQUNBO2dCQUNBO2FBQ0Q7WUFDREMsVUFBVTtZQUNWQyxpQkFBaUI7UUFDbkI7SUFDRjtJQUVBLHVEQUF1RDtJQUN2RCxNQUFNUyxvQkFBb0IzRixpQkFBaUIwRCxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVwRCxlQUFlLEtBQUssVUFBVW9ELEVBQUVJLElBQUksS0FBSyxxQkFBcUJuQyxNQUFNO0lBQzdILElBQUkrRCxvQkFBb0IzRixpQkFBaUI0QixNQUFNLEdBQUcsTUFBTTtRQUN0RGtCLFNBQVM4QixJQUFJLENBQUM7WUFDWkMsTUFBTTtZQUNOQyxPQUFPO1lBQ1BDLGFBQWEsR0FBbUUsT0FBaEVYLEtBQUtDLEtBQUssQ0FBQyxvQkFBcUJyRSxpQkFBaUI0QixNQUFNLEdBQUksTUFBSztZQUNoRm9ELGlCQUFpQjtnQkFDZjtnQkFDQTtnQkFDQTthQUNEO1lBQ0RDLFVBQVU7WUFDVkMsaUJBQWlCO1FBQ25CO0lBQ0Y7SUFFQSxPQUFPcEM7QUFDVCxFQUVBOzs7Ozs7Ozs7OztDQVdDIiwic291cmNlcyI6WyIvVXNlcnMvbHh5aGFuL0dvb2dsZSB4IEhhY2sgVGhlIEZ1dHVyZS9teS1uZXh0anMtYXBwL3NyYy9hcHAvc2VydmljZXMvcmV0dXJucy1wcm9jZXNzb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gYXBwL3NlcnZpY2VzL3JldHVybnMtcHJvY2Vzc29yLmpzXG5cbmltcG9ydCB7IGV4ZWN1dGVSdWxlIH0gZnJvbSAnLi9ydWxlLWV4ZWN1dGlvbi1lbmdpbmUnO1xuaW1wb3J0IHsgZ2V0UmVjZW50UmV0dXJucywgZ2V0UmV0dXJuU3RhdGlzdGljcyB9IGZyb20gJy4uL2FwaS9yZXR1cm5zL2RhdGEnO1xuXG4vKipcbiAqIFByb2Nlc3NlcyBhbGwgcmV0dXJucyB0aHJvdWdoIHRoZSBydWxlIGVuZ2luZSBhbmQgZ2VuZXJhdGVzIHVwZGF0ZWQgc3RhdGlzdGljc1xuICogQHBhcmFtIHtPYmplY3R9IHJ1bGVEZWZpbml0aW9uIC0gVGhlIGV4cG9ydGVkIHJ1bGUgZGVmaW5pdGlvbiBKU09OXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBVcGRhdGVkIHN0YXRpc3RpY3MgYW5kIGNhdGVnb3JpemVkIHJldHVybnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NSZXR1cm5zV2l0aFJ1bGUocnVsZURlZmluaXRpb24pIHtcbiAgLy8gR2V0IGFsbCByZWNlbnQgcmV0dXJuc1xuICBjb25zdCByZXR1cm5zID0gYXdhaXQgZ2V0UmVjZW50UmV0dXJucygpO1xuICBjb25zdCBiYXNlU3RhdGlzdGljcyA9IGF3YWl0IGdldFJldHVyblN0YXRpc3RpY3MoKTtcbiAgXG4gIC8vIFByb2Nlc3MgZWFjaCByZXR1cm4gdGhyb3VnaCB0aGUgcnVsZSBlbmdpbmVcbiAgY29uc3QgcHJvY2Vzc2VkUmV0dXJucyA9IHJldHVybnMubWFwKHJldHVybkl0ZW0gPT4ge1xuICAgIC8vIEZvcm1hdCB0aGUgcmV0dXJuIGRhdGEgaW4gdGhlIHN0cnVjdHVyZSBleHBlY3RlZCBieSB0aGUgcnVsZSBlbmdpbmVcbiAgICBjb25zdCByZXR1cm5EYXRhID0ge1xuICAgICAgaWQ6IHJldHVybkl0ZW0uaWQsXG4gICAgICBjdXN0b21lcklkOiByZXR1cm5JdGVtLmN1c3RvbWVySWQsXG4gICAgICBjdXN0b21lck5hbWU6IHJldHVybkl0ZW0uY3VzdG9tZXJOYW1lLFxuICAgICAgcmV0dXJuRnJlcXVlbmN5OiByZXR1cm5JdGVtLnJldHVybkZyZXF1ZW5jeSB8fCAnTm9ybWFsJyxcbiAgICAgIHB1cmNoYXNlRGF0ZTogcmV0dXJuSXRlbS5kYXRlUHVyY2hhc2VkLFxuICAgICAgcmV0dXJuRGF0ZTogcmV0dXJuSXRlbS5kYXRlUmV0dXJuZWQsXG4gICAgICBpdGVtQ29uZGl0aW9uOiByZXR1cm5JdGVtLml0ZW1zWzBdLmNvbmRpdGlvbj8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnbmV3JykgPyAndW51c2VkJyA6ICd1c2VkJyxcbiAgICAgIG9yaWdpbmFsUGFja2FnaW5nOiByZXR1cm5JdGVtLml0ZW1zWzBdLmNvbmRpdGlvbj8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcygndGFnJykgPyB0cnVlIDogZmFsc2UsXG4gICAgICByZWFzb246IHJldHVybkl0ZW0uaXRlbXNbMF0ucmVhc29uLFxuICAgICAgcmVhc29uRGV0YWlsczogcmV0dXJuSXRlbS5pdGVtc1swXS5yZWFzb25EZXRhaWxzLFxuICAgICAgY3VzdG9tZXJSZXR1cm5zQ291bnQ6IHJldHVybkl0ZW0ucmV0dXJuRnJlcXVlbmN5ID09PSAnSGlnaCcgPyA2IDogMiwgLy8gRXhhbXBsZSBsb2dpY1xuICAgICAgb3JkZXJWYWx1ZTogcmV0dXJuSXRlbS5pdGVtcy5yZWR1Y2UoKHRvdGFsLCBpdGVtKSA9PiB0b3RhbCArIChpdGVtLnByaWNlICogaXRlbS5xdWFudGl0eSksIDApLFxuICAgICAgaXRlbXNDb3VudDogcmV0dXJuSXRlbS5pdGVtcy5sZW5ndGgsXG4gICAgICBjYXRlZ29yaWVzOiBbLi4ubmV3IFNldChyZXR1cm5JdGVtLml0ZW1zLm1hcChpdGVtID0+IGl0ZW0uY2F0ZWdvcnkpKV1cbiAgICB9O1xuICAgIFxuICAgIC8vIEV4ZWN1dGUgdGhlIHJ1bGUgb24gdGhpcyByZXR1cm5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZXhlY3V0ZVJ1bGUocnVsZURlZmluaXRpb24sIHJldHVybkRhdGEpO1xuICAgICAgXG4gICAgICAvLyBDb21iaW5lIG9yaWdpbmFsIHJldHVybiBkYXRhIHdpdGggcnVsZSBwcm9jZXNzaW5nIHJlc3VsdFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmV0dXJuSXRlbSxcbiAgICAgICAgcnVsZVByb2Nlc3NpbmdSZXN1bHQ6IHJlc3VsdC5yZXN1bHQsXG4gICAgICAgIGV4ZWN1dGlvblBhdGg6IHJlc3VsdC5leGVjdXRpb25QYXRoLFxuICAgICAgICBhdXRvUHJvY2Vzc2VkOiByZXN1bHQuaXNDb21wbGV0ZSxcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZXR1cm4gc3RhdHVzIGFuZCBuZXh0IGFjdGlvbnMgYmFzZWQgb24gcnVsZSByZXN1bHRcbiAgICAgICAgc3RhdHVzOiBtYXBSdWxlUmVzdWx0VG9TdGF0dXMocmVzdWx0LnJlc3VsdCwgcmV0dXJuSXRlbS5zdGF0dXMpLFxuICAgICAgICBuZXh0QWN0aW9uOiBtYXBSdWxlUmVzdWx0VG9OZXh0QWN0aW9uKHJlc3VsdC5yZXN1bHQsIHJldHVybkl0ZW0ubmV4dEFjdGlvbilcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgcmV0dXJuICR7cmV0dXJuSXRlbS5pZH06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmV0dXJuSXRlbSxcbiAgICAgICAgcnVsZVByb2Nlc3NpbmdSZXN1bHQ6ICdFUlJPUicsXG4gICAgICAgIGV4ZWN1dGlvblBhdGg6IFtdLFxuICAgICAgICBhdXRvUHJvY2Vzc2VkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBcbiAgLy8gR2VuZXJhdGUgdXBkYXRlZCBzdGF0aXN0aWNzIGJhc2VkIG9uIHJ1bGUgcHJvY2Vzc2luZ1xuICBjb25zdCB1cGRhdGVkU3RhdGlzdGljcyA9IGdlbmVyYXRlVXBkYXRlZFN0YXRpc3RpY3MoYmFzZVN0YXRpc3RpY3MsIHByb2Nlc3NlZFJldHVybnMpO1xuICBcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzZWRSZXR1cm5zLFxuICAgIHN0YXRpc3RpY3M6IHVwZGF0ZWRTdGF0aXN0aWNzLFxuICAgIGluc2lnaHRzOiBnZW5lcmF0ZUluc2lnaHRzRnJvbVByb2Nlc3NpbmcocHJvY2Vzc2VkUmV0dXJucywgdXBkYXRlZFN0YXRpc3RpY3MpXG4gIH07XG59XG5cbi8qKlxuICogTWFwcyBhIHJ1bGUgcmVzdWx0IHRvIGEgcmV0dXJuIHN0YXR1c1xuICovXG5mdW5jdGlvbiBtYXBSdWxlUmVzdWx0VG9TdGF0dXMocnVsZVJlc3VsdCwgY3VycmVudFN0YXR1cykge1xuICBzd2l0Y2ggKHJ1bGVSZXN1bHQpIHtcbiAgICBjYXNlICdBUFBST1ZFRCc6XG4gICAgICByZXR1cm4gJ1Byb2Nlc3NlZCc7XG4gICAgY2FzZSAnUkVKRUNURUQnOlxuICAgICAgcmV0dXJuICdSZWplY3RlZCc7XG4gICAgY2FzZSAnTUFOVUFMX1JFVklFVyc6XG4gICAgICByZXR1cm4gJ1VuZGVyIFJldmlldyc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjdXJyZW50U3RhdHVzO1xuICB9XG59XG5cbi8qKlxuICogTWFwcyBhIHJ1bGUgcmVzdWx0IHRvIGEgbmV4dCBhY3Rpb25cbiAqL1xuZnVuY3Rpb24gbWFwUnVsZVJlc3VsdFRvTmV4dEFjdGlvbihydWxlUmVzdWx0LCBjdXJyZW50TmV4dEFjdGlvbikge1xuICBpZiAocnVsZVJlc3VsdC5zdGFydHNXaXRoKCdPVVRDT01FXycpKSB7XG4gICAgcmV0dXJuIHJ1bGVSZXN1bHQucmVwbGFjZSgnT1VUQ09NRV8nLCAnJyk7XG4gIH1cbiAgXG4gIHN3aXRjaCAocnVsZVJlc3VsdCkge1xuICAgIGNhc2UgJ0FQUFJPVkVEJzpcbiAgICAgIC8vIENoZWNrIHRoZSBjb25kaXRpb24gYW5kIGFzc2lnbiB0byBSZXNhbGUgb3IgUmVmdW5kIFByb2Nlc3MgYmFzZWQgb24gY29uZGl0aW9uXG4gICAgICBpZiAocmV0dXJuSXRlbSAmJiByZXR1cm5JdGVtLml0ZW1zICYmIHJldHVybkl0ZW0uaXRlbXNbMF0gJiYgXG4gICAgICAgICAgKHJldHVybkl0ZW0uaXRlbXNbMF0uY29uZGl0aW9uID09PSAnTGlrZSBOZXcnIHx8IFxuICAgICAgICAgICByZXR1cm5JdGVtLml0ZW1zWzBdLmNvbmRpdGlvbj8uaW5jbHVkZXMoJ05ldycpKSkge1xuICAgICAgICByZXR1cm4gJ1Jlc2FsZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1JlZnVuZCBQcm9jZXNzJztcbiAgICBjYXNlICdSRUpFQ1RFRCc6XG4gICAgICByZXR1cm4gJ1JldHVybiB0byBDdXN0b21lcic7XG4gICAgY2FzZSAnTUFOVUFMX1JFVklFVyc6XG4gICAgICByZXR1cm4gJ1F1YWxpdHkgQXNzZXNzbWVudCc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjdXJyZW50TmV4dEFjdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyB1cGRhdGVkIHN0YXRpc3RpY3MgYmFzZWQgb24gcnVsZSBwcm9jZXNzaW5nIHJlc3VsdHNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVVcGRhdGVkU3RhdGlzdGljcyhiYXNlU3RhdGlzdGljcywgcHJvY2Vzc2VkUmV0dXJucykge1xuICAvLyBDbG9uZSB0aGUgYmFzZSBzdGF0aXN0aWNzXG4gIGNvbnN0IHN0YXRpc3RpY3MgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGJhc2VTdGF0aXN0aWNzKSk7XG4gIFxuICAvLyBVcGRhdGUgdGhlIHN0YXRpc3RpY3MgYmFzZWQgb24gcnVsZSBwcm9jZXNzaW5nXG4gIHN0YXRpc3RpY3Mub3ZlcmFsbC5hcHByb3ZlZCA9IHByb2Nlc3NlZFJldHVybnMuZmlsdGVyKHIgPT4gXG4gICAgci5ydWxlUHJvY2Vzc2luZ1Jlc3VsdCA9PT0gJ0FQUFJPVkVEJyB8fCByLnN0YXR1cyA9PT0gJ1Byb2Nlc3NlZCdcbiAgKS5sZW5ndGg7XG4gIFxuICBzdGF0aXN0aWNzLm92ZXJhbGwuZGVuaWVkID0gcHJvY2Vzc2VkUmV0dXJucy5maWx0ZXIociA9PiBcbiAgICByLnJ1bGVQcm9jZXNzaW5nUmVzdWx0ID09PSAnUkVKRUNURUQnIHx8IHIuc3RhdHVzID09PSAnUmVqZWN0ZWQnXG4gICkubGVuZ3RoO1xuICBcbiAgc3RhdGlzdGljcy5vdmVyYWxsLnBlbmRpbmcgPSBwcm9jZXNzZWRSZXR1cm5zLmZpbHRlcihyID0+IFxuICAgIHIucnVsZVByb2Nlc3NpbmdSZXN1bHQgPT09ICdNQU5VQUxfUkVWSUVXJyB8fCByLnN0YXR1cyA9PT0gJ1VuZGVyIFJldmlldycgfHwgci5zdGF0dXMgPT09ICdJbiBQcm9jZXNzJ1xuICApLmxlbmd0aDtcbiAgXG4gIC8vIENhbGN1bGF0ZSB0aGUgZnJhdWQgc3VzcGVjdGVkIHZhbHVlXG4gIHN0YXRpc3RpY3Mub3ZlcmFsbC5mcmF1ZFN1c3BlY3RlZCA9IHByb2Nlc3NlZFJldHVybnMuZmlsdGVyKHIgPT4gXG4gICAgci5mbGFnID09PSAnRnJlcXVlbnQgcmV0dXJuZXInIHx8IHIucmV0dXJuRnJlcXVlbmN5ID09PSAnSGlnaCcgfHwgKHIucmlza1Njb3JlICYmIHIucmlza1Njb3JlID4gNTApXG4gICkubGVuZ3RoO1xuICBcbiAgLy8gVXBkYXRlIGJ5IHByb2Nlc3Npbmcgc3RhdHVzXG4gIHN0YXRpc3RpY3MuYnlQcm9jZXNzaW5nU3RhdHVzID0gW1xuICAgIHtcbiAgICAgIHN0YXR1czogXCJSZWZ1bmRlZFwiLFxuICAgICAgY291bnQ6IHByb2Nlc3NlZFJldHVybnMuZmlsdGVyKHIgPT4gci5ydWxlUHJvY2Vzc2luZ1Jlc3VsdCA9PT0gJ0FQUFJPVkVEJyB8fCByLnN0YXR1cyA9PT0gJ1Byb2Nlc3NlZCcpLmxlbmd0aCxcbiAgICAgIHBlcmNlbnRhZ2U6IE1hdGgucm91bmQoKHByb2Nlc3NlZFJldHVybnMuZmlsdGVyKHIgPT4gci5ydWxlUHJvY2Vzc2luZ1Jlc3VsdCA9PT0gJ0FQUFJPVkVEJyB8fCByLnN0YXR1cyA9PT0gJ1Byb2Nlc3NlZCcpLmxlbmd0aCAvIHByb2Nlc3NlZFJldHVybnMubGVuZ3RoKSAqIDEwMClcbiAgICB9LFxuICAgIHtcbiAgICAgIHN0YXR1czogXCJSZXNhbGVcIixcbiAgICAgIGNvdW50OiBwcm9jZXNzZWRSZXR1cm5zLmZpbHRlcihyID0+IHIubmV4dEFjdGlvbiA9PT0gJ1Jlc2FsZScpLmxlbmd0aCxcbiAgICAgIHBlcmNlbnRhZ2U6IE1hdGgucm91bmQoKHByb2Nlc3NlZFJldHVybnMuZmlsdGVyKHIgPT4gci5uZXh0QWN0aW9uID09PSAnUmVzYWxlJykubGVuZ3RoIC8gcHJvY2Vzc2VkUmV0dXJucy5sZW5ndGgpICogMTAwKVxuICAgIH0sXG4gICAge1xuICAgICAgc3RhdHVzOiBcIlJlZnVyYmlzaG1lbnRcIixcbiAgICAgIGNvdW50OiBwcm9jZXNzZWRSZXR1cm5zLmZpbHRlcihyID0+IHIubmV4dEFjdGlvbiA9PT0gJ1JlZnVyYmlzaG1lbnQnKS5sZW5ndGgsXG4gICAgICBwZXJjZW50YWdlOiBNYXRoLnJvdW5kKChwcm9jZXNzZWRSZXR1cm5zLmZpbHRlcihyID0+IHIubmV4dEFjdGlvbiA9PT0gJ1JlZnVyYmlzaG1lbnQnKS5sZW5ndGggLyBwcm9jZXNzZWRSZXR1cm5zLmxlbmd0aCkgKiAxMDApXG4gICAgfSxcbiAgICB7XG4gICAgICBzdGF0dXM6IFwiRGFtYWdlZC9Xcml0ZS1vZmZcIixcbiAgICAgIGNvdW50OiBwcm9jZXNzZWRSZXR1cm5zLmZpbHRlcihyID0+IHIubmV4dEFjdGlvbiA9PT0gJ1F1YWxpdHkgQXNzZXNzbWVudCcpLmxlbmd0aCxcbiAgICAgIHBlcmNlbnRhZ2U6IE1hdGgucm91bmQoKHByb2Nlc3NlZFJldHVybnMuZmlsdGVyKHIgPT4gci5uZXh0QWN0aW9uID09PSAnUXVhbGl0eSBBc3Nlc3NtZW50JykubGVuZ3RoIC8gcHJvY2Vzc2VkUmV0dXJucy5sZW5ndGgpICogMTAwKVxuICAgIH1cbiAgXTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBhdXRvLXByb2Nlc3NpbmcgZWZmZWN0aXZlbmVzc1xuICBjb25zdCBhdXRvbWF0aWNhbGx5UHJvY2Vzc2VkID0gcHJvY2Vzc2VkUmV0dXJucy5maWx0ZXIociA9PiByLmF1dG9Qcm9jZXNzZWQpLmxlbmd0aDtcbiAgc3RhdGlzdGljcy5hdXRvbWF0aW9uTWV0cmljcyA9IHtcbiAgICBhdXRvbWF0aWNhbGx5UHJvY2Vzc2VkLFxuICAgIGF1dG9tYXRpb25SYXRlOiBNYXRoLnJvdW5kKChhdXRvbWF0aWNhbGx5UHJvY2Vzc2VkIC8gcHJvY2Vzc2VkUmV0dXJucy5sZW5ndGgpICogMTAwKSxcbiAgICBtYW51YWxSZXZpZXdSYXRlOiBNYXRoLnJvdW5kKChwcm9jZXNzZWRSZXR1cm5zLmZpbHRlcihyID0+IHIucnVsZVByb2Nlc3NpbmdSZXN1bHQgPT09ICdNQU5VQUxfUkVWSUVXJykubGVuZ3RoIC8gcHJvY2Vzc2VkUmV0dXJucy5sZW5ndGgpICogMTAwKSxcbiAgICBhdmVyYWdlUGF0aExlbmd0aDogTWF0aC5yb3VuZChwcm9jZXNzZWRSZXR1cm5zLnJlZHVjZSgoc3VtLCByKSA9PiBzdW0gKyAoci5leGVjdXRpb25QYXRoPy5sZW5ndGggfHwgMCksIDApIC8gcHJvY2Vzc2VkUmV0dXJucy5sZW5ndGgpXG4gIH07XG4gIFxuICByZXR1cm4gc3RhdGlzdGljcztcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgaW5zaWdodHMgYmFzZWQgb24gcnVsZSBwcm9jZXNzaW5nXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlSW5zaWdodHNGcm9tUHJvY2Vzc2luZyhwcm9jZXNzZWRSZXR1cm5zLCBzdGF0aXN0aWNzKSB7XG4gIGNvbnN0IGluc2lnaHRzID0gW107XG4gIFxuICAvLyBDaGVjayBmb3IgaGlnaCBhdXRvbWF0aW9uIG9wcG9ydHVuaXRpZXNcbiAgaWYgKHN0YXRpc3RpY3MuYXV0b21hdGlvbk1ldHJpY3MuYXV0b21hdGlvblJhdGUgPCA3MCkge1xuICAgIGluc2lnaHRzLnB1c2goe1xuICAgICAgdHlwZTogXCJ0cmVuZFwiLFxuICAgICAgdGl0bGU6IFwiQXV0b21hdGlvbiBPcHBvcnR1bml0eVwiLFxuICAgICAgZGVzY3JpcHRpb246IGBDdXJyZW50IGF1dG9tYXRpb24gcmF0ZSBpcyAke3N0YXRpc3RpY3MuYXV0b21hdGlvbk1ldHJpY3MuYXV0b21hdGlvblJhdGV9JS4gQ29uc2lkZXIgYWRkaXRpb25hbCBydWxlIHJlZmluZW1lbnRzLmAsXG4gICAgICByZWNvbW1lbmRhdGlvbnM6IFtcbiAgICAgICAgXCJBZGQgbW9yZSBjb25kaXRpb24gYmxvY2tzIHRvIHlvdXIgcnVsZSBmbG93XCIsXG4gICAgICAgIFwiUmVmaW5lIGV4aXN0aW5nIGNvbmRpdGlvbnMgdG8gYmUgbW9yZSBzcGVjaWZpY1wiLFxuICAgICAgICBcIkNyZWF0ZSBzZXBhcmF0ZSBydWxlcyBmb3IgZGlmZmVyZW50IHByb2R1Y3QgY2F0ZWdvcmllc1wiXG4gICAgICBdLFxuICAgICAgcHJpb3JpdHk6IFwiTWVkaXVtXCIsXG4gICAgICBwb3RlbnRpYWxJbXBhY3Q6IFwiUmVkdWNlZCBwcm9jZXNzaW5nIGNvc3RzXCJcbiAgICB9KTtcbiAgfVxuICBcbiAgLy8gQ2hlY2sgZm9yIGhpZ2ggbWFudWFsIHJldmlldyByYXRlXG4gIGlmIChzdGF0aXN0aWNzLmF1dG9tYXRpb25NZXRyaWNzLm1hbnVhbFJldmlld1JhdGUgPiAzMCkge1xuICAgIGluc2lnaHRzLnB1c2goe1xuICAgICAgdHlwZTogXCJpbnZlbnRvcnlcIixcbiAgICAgIHRpdGxlOiBcIkhpZ2ggTWFudWFsIFJldmlldyBSYXRlXCIsXG4gICAgICBkZXNjcmlwdGlvbjogYCR7c3RhdGlzdGljcy5hdXRvbWF0aW9uTWV0cmljcy5tYW51YWxSZXZpZXdSYXRlfSUgb2YgcmV0dXJucyBhcmUgYmVpbmcgc2VudCBmb3IgbWFudWFsIHJldmlldy4gVGhpcyBpbmNyZWFzZXMgcHJvY2Vzc2luZyB0aW1lLmAsXG4gICAgICByZWNvbW1lbmRhdGlvbnM6IFtcbiAgICAgICAgXCJSZWZpbmUgcnVsZSBjb25kaXRpb25zIHRvIHJlZHVjZSBtYW51YWwgcmV2aWV3c1wiLFxuICAgICAgICBcIkFkZCBtb3JlIHNwZWNpZmljIHJ1bGVzIGZvciBjb21tb24gcmV0dXJuIHNjZW5hcmlvc1wiXG4gICAgICBdLFxuICAgICAgcHJpb3JpdHk6IFwiSGlnaFwiLFxuICAgICAgcG90ZW50aWFsSW1wYWN0OiBcIkZhc3RlciBwcm9jZXNzaW5nLCBpbXByb3ZlZCBjdXN0b21lciBzYXRpc2ZhY3Rpb25cIlxuICAgIH0pO1xuICB9XG4gIFxuICAvLyBDaGVjayBmb3IgcmV0dXJuIHJlYXNvbnMgdGhhdCBtaWdodCBuZWVkIGF0dGVudGlvblxuICBjb25zdCByZWFzb25Db3VudHMgPSB7fTtcbiAgcHJvY2Vzc2VkUmV0dXJucy5mb3JFYWNoKHIgPT4ge1xuICAgIGNvbnN0IHJlYXNvbiA9IHIuaXRlbXNbMF0ucmVhc29uO1xuICAgIHJlYXNvbkNvdW50c1tyZWFzb25dID0gKHJlYXNvbkNvdW50c1tyZWFzb25dIHx8IDApICsgMTtcbiAgfSk7XG4gIFxuICBjb25zdCB0b3BSZWFzb24gPSBPYmplY3QuZW50cmllcyhyZWFzb25Db3VudHMpLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKVswXTtcbiAgaWYgKHRvcFJlYXNvbiAmJiB0b3BSZWFzb25bMV0gPiBwcm9jZXNzZWRSZXR1cm5zLmxlbmd0aCAqIDAuMykge1xuICAgIGluc2lnaHRzLnB1c2goe1xuICAgICAgdHlwZTogXCJjdXN0b21lclwiLFxuICAgICAgdGl0bGU6IGBIaWdoIFJldHVybiBSYXRlOiBcIiR7dG9wUmVhc29uWzBdfVwiYCxcbiAgICAgIGRlc2NyaXB0aW9uOiBgJHtNYXRoLnJvdW5kKCh0b3BSZWFzb25bMV0gLyBwcm9jZXNzZWRSZXR1cm5zLmxlbmd0aCkgKiAxMDApfSUgb2YgcmV0dXJucyBjaXRlIFwiJHt0b3BSZWFzb25bMF19XCIgYXMgdGhlIHJlYXNvbi5gLFxuICAgICAgcmVjb21tZW5kYXRpb25zOiBbXG4gICAgICAgIFwiUmV2aWV3IHByb2R1Y3QgZGVzY3JpcHRpb25zIGFuZCBzaXppbmcgaW5mb3JtYXRpb25cIixcbiAgICAgICAgXCJDb25zaWRlciBhZGp1c3RpbmcgcHJvZHVjdCBkZXNpZ24gb3IgZmVhdHVyZXNcIixcbiAgICAgICAgXCJBZGQgbW9yZSBkZXRhaWxlZCBwcm9kdWN0IGluZm9ybWF0aW9uIHRvIHJlZHVjZSBleHBlY3RhdGlvbiBtaXNtYXRjaFwiXG4gICAgICBdLFxuICAgICAgcHJpb3JpdHk6IFwiSGlnaFwiLFxuICAgICAgcG90ZW50aWFsSW1wYWN0OiBcIlJlZHVjZWQgcmV0dXJuIHJhdGUsIGluY3JlYXNlZCBjdXN0b21lciBzYXRpc2ZhY3Rpb25cIlxuICAgIH0pO1xuICB9XG4gIFxuICAvLyBJZiB0aGVyZSBhcmUgbWFueSBmcmVxdWVudCByZXR1cm5lcnMsIGFkZCBhbiBpbnNpZ2h0XG4gIGNvbnN0IGZyZXF1ZW50UmV0dXJuZXJzID0gcHJvY2Vzc2VkUmV0dXJucy5maWx0ZXIociA9PiByLnJldHVybkZyZXF1ZW5jeSA9PT0gJ0hpZ2gnIHx8IHIuZmxhZyA9PT0gJ0ZyZXF1ZW50IHJldHVybmVyJykubGVuZ3RoO1xuICBpZiAoZnJlcXVlbnRSZXR1cm5lcnMgPiBwcm9jZXNzZWRSZXR1cm5zLmxlbmd0aCAqIDAuMTUpIHtcbiAgICBpbnNpZ2h0cy5wdXNoKHtcbiAgICAgIHR5cGU6IFwiZnJhdWRcIixcbiAgICAgIHRpdGxlOiBcIkhpZ2ggUmF0ZSBvZiBGcmVxdWVudCBSZXR1cm5lcnNcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBgJHtNYXRoLnJvdW5kKChmcmVxdWVudFJldHVybmVycyAvIHByb2Nlc3NlZFJldHVybnMubGVuZ3RoKSAqIDEwMCl9JSBvZiByZXR1cm5zIGFyZSBmcm9tIGZyZXF1ZW50IHJldHVybmVycy5gLFxuICAgICAgcmVjb21tZW5kYXRpb25zOiBbXG4gICAgICAgIFwiUmV2aWV3IGN1cnJlbnQgcmV0dXJuIHBvbGljeSBsaW1pdHNcIixcbiAgICAgICAgXCJDb25zaWRlciBpbXBsZW1lbnRpbmcgYSByZXR1cm4gZmVlIGZvciBleGNlc3NpdmUgcmV0dXJuc1wiLFxuICAgICAgICBcIkNyZWF0ZSBzcGVjaWFsIHJ1bGVzIGZvciBoYW5kbGluZyBmcmVxdWVudCByZXR1cm5lcnNcIlxuICAgICAgXSxcbiAgICAgIHByaW9yaXR5OiBcIk1lZGl1bVwiLFxuICAgICAgcG90ZW50aWFsSW1wYWN0OiBcIlJlZHVjZWQgcmV0dXJuIGFidXNlLCBiZXR0ZXIgcHJvZml0IG1hcmdpbnNcIlxuICAgIH0pO1xuICB9XG4gIFxuICByZXR1cm4gaW5zaWdodHM7XG59XG5cbi8qKlxuICogRXhhbXBsZSB1c2FnZTpcbiAqIFxuICogLy8gTG9hZCB5b3VyIGV4cG9ydGVkIHJ1bGUgZGVmaW5pdGlvbiBKU09OXG4gKiBpbXBvcnQgbXlSdWxlRGVmaW5pdGlvbiBmcm9tICcuL215X3JldHVybl9wb2xpY3lfcnVsZS5qc29uJztcbiAqIFxuICogLy8gUHJvY2VzcyBhbGwgcmV0dXJucyB1c2luZyB0aGlzIHJ1bGVcbiAqIGNvbnN0IHsgcHJvY2Vzc2VkUmV0dXJucywgc3RhdGlzdGljcywgaW5zaWdodHMgfSA9IGF3YWl0IHByb2Nlc3NSZXR1cm5zV2l0aFJ1bGUobXlSdWxlRGVmaW5pdGlvbik7XG4gKiBcbiAqIC8vIE5vdyB5b3UgY2FuIHVwZGF0ZSB5b3VyIGRhc2hib2FyZCB3aXRoIHRoaXMgZGF0YVxuICogdXBkYXRlRGFzaGJvYXJkKHByb2Nlc3NlZFJldHVybnMsIHN0YXRpc3RpY3MsIGluc2lnaHRzKTtcbiAqLyJdLCJuYW1lcyI6WyJleGVjdXRlUnVsZSIsImdldFJlY2VudFJldHVybnMiLCJnZXRSZXR1cm5TdGF0aXN0aWNzIiwicHJvY2Vzc1JldHVybnNXaXRoUnVsZSIsInJ1bGVEZWZpbml0aW9uIiwicmV0dXJucyIsImJhc2VTdGF0aXN0aWNzIiwicHJvY2Vzc2VkUmV0dXJucyIsIm1hcCIsInJldHVybkl0ZW0iLCJyZXR1cm5EYXRhIiwiaWQiLCJjdXN0b21lcklkIiwiY3VzdG9tZXJOYW1lIiwicmV0dXJuRnJlcXVlbmN5IiwicHVyY2hhc2VEYXRlIiwiZGF0ZVB1cmNoYXNlZCIsInJldHVybkRhdGUiLCJkYXRlUmV0dXJuZWQiLCJpdGVtQ29uZGl0aW9uIiwiaXRlbXMiLCJjb25kaXRpb24iLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwib3JpZ2luYWxQYWNrYWdpbmciLCJyZWFzb24iLCJyZWFzb25EZXRhaWxzIiwiY3VzdG9tZXJSZXR1cm5zQ291bnQiLCJvcmRlclZhbHVlIiwicmVkdWNlIiwidG90YWwiLCJpdGVtIiwicHJpY2UiLCJxdWFudGl0eSIsIml0ZW1zQ291bnQiLCJsZW5ndGgiLCJjYXRlZ29yaWVzIiwiU2V0IiwiY2F0ZWdvcnkiLCJyZXN1bHQiLCJydWxlUHJvY2Vzc2luZ1Jlc3VsdCIsImV4ZWN1dGlvblBhdGgiLCJhdXRvUHJvY2Vzc2VkIiwiaXNDb21wbGV0ZSIsInN0YXR1cyIsIm1hcFJ1bGVSZXN1bHRUb1N0YXR1cyIsIm5leHRBY3Rpb24iLCJtYXBSdWxlUmVzdWx0VG9OZXh0QWN0aW9uIiwiZXJyb3IiLCJjb25zb2xlIiwidXBkYXRlZFN0YXRpc3RpY3MiLCJnZW5lcmF0ZVVwZGF0ZWRTdGF0aXN0aWNzIiwic3RhdGlzdGljcyIsImluc2lnaHRzIiwiZ2VuZXJhdGVJbnNpZ2h0c0Zyb21Qcm9jZXNzaW5nIiwicnVsZVJlc3VsdCIsImN1cnJlbnRTdGF0dXMiLCJjdXJyZW50TmV4dEFjdGlvbiIsInN0YXJ0c1dpdGgiLCJyZXBsYWNlIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5Iiwib3ZlcmFsbCIsImFwcHJvdmVkIiwiZmlsdGVyIiwiciIsImRlbmllZCIsInBlbmRpbmciLCJmcmF1ZFN1c3BlY3RlZCIsImZsYWciLCJyaXNrU2NvcmUiLCJieVByb2Nlc3NpbmdTdGF0dXMiLCJjb3VudCIsInBlcmNlbnRhZ2UiLCJNYXRoIiwicm91bmQiLCJhdXRvbWF0aWNhbGx5UHJvY2Vzc2VkIiwiYXV0b21hdGlvbk1ldHJpY3MiLCJhdXRvbWF0aW9uUmF0ZSIsIm1hbnVhbFJldmlld1JhdGUiLCJhdmVyYWdlUGF0aExlbmd0aCIsInN1bSIsInB1c2giLCJ0eXBlIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsInJlY29tbWVuZGF0aW9ucyIsInByaW9yaXR5IiwicG90ZW50aWFsSW1wYWN0IiwicmVhc29uQ291bnRzIiwiZm9yRWFjaCIsInRvcFJlYXNvbiIsIk9iamVjdCIsImVudHJpZXMiLCJzb3J0IiwiYSIsImIiLCJmcmVxdWVudFJldHVybmVycyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/services/returns-processor.js\n"));

/***/ })

});