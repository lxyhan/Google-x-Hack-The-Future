"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/storefront/page",{

/***/ "(app-pages-browser)/./src/app/services/returns-processor.js":
/*!***********************************************!*\
  !*** ./src/app/services/returns-processor.js ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   processReturnsWithRule: () => (/* binding */ processReturnsWithRule)\n/* harmony export */ });\n/* harmony import */ var _rule_execution_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rule-execution-engine */ \"(app-pages-browser)/./src/app/services/rule-execution-engine.js\");\n/* harmony import */ var _api_returns_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/returns/data */ \"(app-pages-browser)/./src/app/api/returns/data.js\");\n// app/services/returns-processor.js\n\n\n/**\n * Processes all returns through the rule engine and generates updated statistics\n * @param {Object} ruleDefinition - The exported rule definition JSON\n * @returns {Object} Updated statistics and categorized returns\n */ async function processReturnsWithRule(ruleDefinition) {\n    // Get all recent returns\n    const returns = await (0,_api_returns_data__WEBPACK_IMPORTED_MODULE_1__.getRecentReturns)();\n    const baseStatistics = await (0,_api_returns_data__WEBPACK_IMPORTED_MODULE_1__.getReturnStatistics)();\n    // Process each return through the rule engine\n    const processedReturns = returns.map((returnItem)=>{\n        var _returnItem_items__condition, _returnItem_items__condition1;\n        // Format the return data in the structure expected by the rule engine\n        const returnData = {\n            id: returnItem.id,\n            customerId: returnItem.customerId,\n            customerName: returnItem.customerName,\n            returnFrequency: returnItem.returnFrequency || 'Normal',\n            purchaseDate: returnItem.datePurchased,\n            returnDate: returnItem.dateReturned,\n            itemCondition: ((_returnItem_items__condition = returnItem.items[0].condition) === null || _returnItem_items__condition === void 0 ? void 0 : _returnItem_items__condition.toLowerCase().includes('new')) ? 'unused' : 'used',\n            originalPackaging: ((_returnItem_items__condition1 = returnItem.items[0].condition) === null || _returnItem_items__condition1 === void 0 ? void 0 : _returnItem_items__condition1.toLowerCase().includes('tag')) ? true : false,\n            reason: returnItem.items[0].reason,\n            reasonDetails: returnItem.items[0].reasonDetails,\n            customerReturnsCount: returnItem.returnFrequency === 'High' ? 6 : 2,\n            orderValue: returnItem.items.reduce((total, item)=>total + item.price * item.quantity, 0),\n            itemsCount: returnItem.items.length,\n            categories: [\n                ...new Set(returnItem.items.map((item)=>item.category))\n            ]\n        };\n        // Execute the rule on this return\n        try {\n            const result = (0,_rule_execution_engine__WEBPACK_IMPORTED_MODULE_0__.executeRule)(ruleDefinition, returnData);\n            // Combine original return data with rule processing result\n            return {\n                ...returnItem,\n                ruleProcessingResult: result.result,\n                executionPath: result.executionPath,\n                autoProcessed: result.isComplete,\n                // Update the return status and next actions based on rule result\n                status: mapRuleResultToStatus(result.result, returnItem.status),\n                nextAction: mapRuleResultToNextAction(result.result, returnItem.nextAction)\n            };\n        } catch (error) {\n            console.error(\"Error processing return \".concat(returnItem.id, \":\"), error);\n            return {\n                ...returnItem,\n                ruleProcessingResult: 'ERROR',\n                executionPath: [],\n                autoProcessed: false\n            };\n        }\n    });\n    // Generate updated statistics based on rule processing\n    const updatedStatistics = generateUpdatedStatistics(baseStatistics, processedReturns);\n    return {\n        processedReturns,\n        statistics: updatedStatistics,\n        insights: generateInsightsFromProcessing(processedReturns, updatedStatistics)\n    };\n}\n/**\n * Maps a rule result to a return status\n */ function mapRuleResultToStatus(ruleResult, currentStatus) {\n    switch(ruleResult){\n        case 'APPROVED':\n            return 'Processed';\n        case 'REJECTED':\n            return 'Rejected';\n        case 'MANUAL_REVIEW':\n            return 'Under Review';\n        default:\n            return currentStatus;\n    }\n}\n/**\n * Maps a rule result to a next action\n */ /**\n * Maps a rule result to a next action\n */ function mapRuleResultToNextAction(ruleResult, currentNextAction, returnItem) {\n    if (ruleResult.startsWith('OUTCOME_')) {\n        return ruleResult.replace('OUTCOME_', '');\n    }\n    switch(ruleResult){\n        case 'APPROVED':\n            var _returnItem_items__condition;\n            // Check the condition and assign to Resale or Refund Process based on condition\n            if (returnItem && returnItem.items && returnItem.items[0] && (returnItem.items[0].condition === 'Like New' || ((_returnItem_items__condition = returnItem.items[0].condition) === null || _returnItem_items__condition === void 0 ? void 0 : _returnItem_items__condition.includes('New')))) {\n                return 'Resale';\n            }\n            return 'Refund Process';\n        case 'REJECTED':\n            return 'Return to Customer';\n        case 'MANUAL_REVIEW':\n            return 'Quality Assessment';\n        default:\n            return currentNextAction;\n    }\n}\n/**\n * Generates updated statistics based on rule processing results\n */ function generateUpdatedStatistics(baseStatistics, processedReturns) {\n    // Clone the base statistics\n    const statistics = JSON.parse(JSON.stringify(baseStatistics));\n    // Update the statistics based on rule processing\n    statistics.overall.approved = processedReturns.filter((r)=>r.ruleProcessingResult === 'APPROVED' || r.status === 'Processed').length;\n    statistics.overall.denied = processedReturns.filter((r)=>r.ruleProcessingResult === 'REJECTED' || r.status === 'Rejected').length;\n    statistics.overall.pending = processedReturns.filter((r)=>r.ruleProcessingResult === 'MANUAL_REVIEW' || r.status === 'Under Review' || r.status === 'In Process').length;\n    // Calculate the fraud suspected value\n    statistics.overall.fraudSuspected = processedReturns.filter((r)=>r.flag === 'Frequent returner' || r.returnFrequency === 'High' || r.riskScore && r.riskScore > 50).length;\n    // Update by processing status\n    statistics.byProcessingStatus = [\n        {\n            status: \"Refunded\",\n            count: processedReturns.filter((r)=>r.ruleProcessingResult === 'APPROVED' || r.status === 'Processed').length,\n            percentage: Math.round(processedReturns.filter((r)=>r.ruleProcessingResult === 'APPROVED' || r.status === 'Processed').length / processedReturns.length * 100)\n        },\n        {\n            status: \"Resale\",\n            count: processedReturns.filter((r)=>r.nextAction === 'Resale').length,\n            percentage: Math.round(processedReturns.filter((r)=>r.nextAction === 'Resale').length / processedReturns.length * 100)\n        },\n        {\n            status: \"Refurbishment\",\n            count: processedReturns.filter((r)=>r.nextAction === 'Refurbishment').length,\n            percentage: Math.round(processedReturns.filter((r)=>r.nextAction === 'Refurbishment').length / processedReturns.length * 100)\n        },\n        {\n            status: \"Damaged/Write-off\",\n            count: processedReturns.filter((r)=>r.nextAction === 'Quality Assessment').length,\n            percentage: Math.round(processedReturns.filter((r)=>r.nextAction === 'Quality Assessment').length / processedReturns.length * 100)\n        }\n    ];\n    // Calculate auto-processing effectiveness\n    const automaticallyProcessed = processedReturns.filter((r)=>r.autoProcessed).length;\n    statistics.automationMetrics = {\n        automaticallyProcessed,\n        automationRate: Math.round(automaticallyProcessed / processedReturns.length * 100),\n        manualReviewRate: Math.round(processedReturns.filter((r)=>r.ruleProcessingResult === 'MANUAL_REVIEW').length / processedReturns.length * 100),\n        averagePathLength: Math.round(processedReturns.reduce((sum, r)=>{\n            var _r_executionPath;\n            return sum + (((_r_executionPath = r.executionPath) === null || _r_executionPath === void 0 ? void 0 : _r_executionPath.length) || 0);\n        }, 0) / processedReturns.length)\n    };\n    return statistics;\n}\n/**\n * Generates insights based on rule processing\n */ function generateInsightsFromProcessing(processedReturns, statistics) {\n    const insights = [];\n    // Check for high automation opportunities\n    if (statistics.automationMetrics.automationRate < 70) {\n        insights.push({\n            type: \"trend\",\n            title: \"Automation Opportunity\",\n            description: \"Current automation rate is \".concat(statistics.automationMetrics.automationRate, \"%. Consider additional rule refinements.\"),\n            recommendations: [\n                \"Add more condition blocks to your rule flow\",\n                \"Refine existing conditions to be more specific\",\n                \"Create separate rules for different product categories\"\n            ],\n            priority: \"Medium\",\n            potentialImpact: \"Reduced processing costs\"\n        });\n    }\n    // Check for high manual review rate\n    if (statistics.automationMetrics.manualReviewRate > 30) {\n        insights.push({\n            type: \"inventory\",\n            title: \"High Manual Review Rate\",\n            description: \"\".concat(statistics.automationMetrics.manualReviewRate, \"% of returns are being sent for manual review. This increases processing time.\"),\n            recommendations: [\n                \"Refine rule conditions to reduce manual reviews\",\n                \"Add more specific rules for common return scenarios\"\n            ],\n            priority: \"High\",\n            potentialImpact: \"Faster processing, improved customer satisfaction\"\n        });\n    }\n    // Check for return reasons that might need attention\n    const reasonCounts = {};\n    processedReturns.forEach((r)=>{\n        const reason = r.items[0].reason;\n        reasonCounts[reason] = (reasonCounts[reason] || 0) + 1;\n    });\n    const topReason = Object.entries(reasonCounts).sort((a, b)=>b[1] - a[1])[0];\n    if (topReason && topReason[1] > processedReturns.length * 0.3) {\n        insights.push({\n            type: \"customer\",\n            title: 'High Return Rate: \"'.concat(topReason[0], '\"'),\n            description: \"\".concat(Math.round(topReason[1] / processedReturns.length * 100), '% of returns cite \"').concat(topReason[0], '\" as the reason.'),\n            recommendations: [\n                \"Review product descriptions and sizing information\",\n                \"Consider adjusting product design or features\",\n                \"Add more detailed product information to reduce expectation mismatch\"\n            ],\n            priority: \"High\",\n            potentialImpact: \"Reduced return rate, increased customer satisfaction\"\n        });\n    }\n    // If there are many frequent returners, add an insight\n    const frequentReturners = processedReturns.filter((r)=>r.returnFrequency === 'High' || r.flag === 'Frequent returner').length;\n    if (frequentReturners > processedReturns.length * 0.15) {\n        insights.push({\n            type: \"fraud\",\n            title: \"High Rate of Frequent Returners\",\n            description: \"\".concat(Math.round(frequentReturners / processedReturns.length * 100), \"% of returns are from frequent returners.\"),\n            recommendations: [\n                \"Review current return policy limits\",\n                \"Consider implementing a return fee for excessive returns\",\n                \"Create special rules for handling frequent returners\"\n            ],\n            priority: \"Medium\",\n            potentialImpact: \"Reduced return abuse, better profit margins\"\n        });\n    }\n    return insights;\n} /**\n * Example usage:\n * \n * // Load your exported rule definition JSON\n * import myRuleDefinition from './my_return_policy_rule.json';\n * \n * // Process all returns using this rule\n * const { processedReturns, statistics, insights } = await processReturnsWithRule(myRuleDefinition);\n * \n * // Now you can update your dashboard with this data\n * updateDashboard(processedReturns, statistics, insights);\n */ \n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvc2VydmljZXMvcmV0dXJucy1wcm9jZXNzb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsb0NBQW9DO0FBRWtCO0FBQ3NCO0FBRTVFOzs7O0NBSUMsR0FDTSxlQUFlRyx1QkFBdUJDLGNBQWM7SUFDekQseUJBQXlCO0lBQ3pCLE1BQU1DLFVBQVUsTUFBTUosbUVBQWdCQTtJQUN0QyxNQUFNSyxpQkFBaUIsTUFBTUosc0VBQW1CQTtJQUVoRCw4Q0FBOEM7SUFDOUMsTUFBTUssbUJBQW1CRixRQUFRRyxHQUFHLENBQUNDLENBQUFBO1lBU2xCQSw4QkFDSUE7UUFUckIsc0VBQXNFO1FBQ3RFLE1BQU1DLGFBQWE7WUFDakJDLElBQUlGLFdBQVdFLEVBQUU7WUFDakJDLFlBQVlILFdBQVdHLFVBQVU7WUFDakNDLGNBQWNKLFdBQVdJLFlBQVk7WUFDckNDLGlCQUFpQkwsV0FBV0ssZUFBZSxJQUFJO1lBQy9DQyxjQUFjTixXQUFXTyxhQUFhO1lBQ3RDQyxZQUFZUixXQUFXUyxZQUFZO1lBQ25DQyxlQUFlVixFQUFBQSwrQkFBQUEsV0FBV1csS0FBSyxDQUFDLEVBQUUsQ0FBQ0MsU0FBUyxjQUE3QlosbURBQUFBLDZCQUErQmEsV0FBVyxHQUFHQyxRQUFRLENBQUMsVUFBUyxXQUFXO1lBQ3pGQyxtQkFBbUJmLEVBQUFBLGdDQUFBQSxXQUFXVyxLQUFLLENBQUMsRUFBRSxDQUFDQyxTQUFTLGNBQTdCWixvREFBQUEsOEJBQStCYSxXQUFXLEdBQUdDLFFBQVEsQ0FBQyxVQUFTLE9BQU87WUFDekZFLFFBQVFoQixXQUFXVyxLQUFLLENBQUMsRUFBRSxDQUFDSyxNQUFNO1lBQ2xDQyxlQUFlakIsV0FBV1csS0FBSyxDQUFDLEVBQUUsQ0FBQ00sYUFBYTtZQUNoREMsc0JBQXNCbEIsV0FBV0ssZUFBZSxLQUFLLFNBQVMsSUFBSTtZQUNsRWMsWUFBWW5CLFdBQVdXLEtBQUssQ0FBQ1MsTUFBTSxDQUFDLENBQUNDLE9BQU9D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WUFDTkMsT0FBTyxzQkFBbUMsT0FBYk8sU0FBUyxDQUFDLEVBQUUsRUFBQztZQUMxQ04sYUFBYSxHQUFtRk0sT0FBaEZqQixLQUFLQyxLQUFLLENBQUMsU0FBVSxDQUFDLEVBQUUsR0FBR3JFLGlCQUFpQjRCLE1BQU0sR0FBSSxNQUFLLHVCQUFrQyxPQUFieUQsU0FBUyxDQUFDLEVBQUUsRUFBQztZQUM3R0wsaUJBQWlCO2dCQUNmO2dCQUNBO2dCQUNBO2FBQ0Q7WUFDREMsVUFBVTtZQUNWQyxpQkFBaUI7UUFDbkI7SUFDRjtJQUVBLHVEQUF1RDtJQUN2RCxNQUFNUyxvQkFBb0IzRixpQkFBaUIwRCxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVwRCxlQUFlLEtBQUssVUFBVW9ELEVBQUVJLElBQUksS0FBSyxxQkFBcUJuQyxNQUFNO0lBQzdILElBQUkrRCxvQkFBb0IzRixpQkFBaUI0QixNQUFNLEdBQUcsTUFBTTtRQUN0RGtCLFNBQVM4QixJQUFJLENBQUM7WUFDWkMsTUFBTTtZQUNOQyxPQUFPO1lBQ1BDLGFBQWEsR0FBbUUsT0FBaEVYLEtBQUtDLEtBQUssQ0FBQyxvQkFBcUJyRSxpQkFBaUI0QixNQUFNLEdBQUksTUFBSztZQUNoRm9ELGlCQUFpQjtnQkFDZjtnQkFDQTtnQkFDQTthQUNEO1lBQ0RDLFVBQVU7WUFDVkMsaUJBQWlCO1FBQ25CO0lBQ0Y7SUFFQSxPQUFPcEM7QUFDVCxFQUVBOzs7Ozs7Ozs7OztDQVdDIiwic291cmNlcyI6WyIvVXNlcnMvbHh5aGFuL0dvb2dsZSB4IEhhY2sgVGhlIEZ1dHVyZS9teS1uZXh0anMtYXBwL3NyYy9hcHAvc2VydmljZXMvcmV0dXJucy1wcm9jZXNzb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gYXBwL3NlcnZpY2VzL3JldHVybnMtcHJvY2Vzc29yLmpzXG5cbmltcG9ydCB7IGV4ZWN1dGVSdWxlIH0gZnJvbSAnLi9ydWxlLWV4ZWN1dGlvbi1lbmdpbmUnO1xuaW1wb3J0IHsgZ2V0UmVjZW50UmV0dXJucywgZ2V0UmV0dXJuU3RhdGlzdGljcyB9IGZyb20gJy4uL2FwaS9yZXR1cm5zL2RhdGEnO1xuXG4vKipcbiAqIFByb2Nlc3NlcyBhbGwgcmV0dXJucyB0aHJvdWdoIHRoZSBydWxlIGVuZ2luZSBhbmQgZ2VuZXJhdGVzIHVwZGF0ZWQgc3RhdGlzdGljc1xuICogQHBhcmFtIHtPYmplY3R9IHJ1bGVEZWZpbml0aW9uIC0gVGhlIGV4cG9ydGVkIHJ1bGUgZGVmaW5pdGlvbiBKU09OXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBVcGRhdGVkIHN0YXRpc3RpY3MgYW5kIGNhdGVnb3JpemVkIHJldHVybnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NSZXR1cm5zV2l0aFJ1bGUocnVsZURlZmluaXRpb24pIHtcbiAgLy8gR2V0IGFsbCByZWNlbnQgcmV0dXJuc1xuICBjb25zdCByZXR1cm5zID0gYXdhaXQgZ2V0UmVjZW50UmV0dXJucygpO1xuICBjb25zdCBiYXNlU3RhdGlzdGljcyA9IGF3YWl0IGdldFJldHVyblN0YXRpc3RpY3MoKTtcbiAgXG4gIC8vIFByb2Nlc3MgZWFjaCByZXR1cm4gdGhyb3VnaCB0aGUgcnVsZSBlbmdpbmVcbiAgY29uc3QgcHJvY2Vzc2VkUmV0dXJucyA9IHJldHVybnMubWFwKHJldHVybkl0ZW0gPT4ge1xuICAgIC8vIEZvcm1hdCB0aGUgcmV0dXJuIGRhdGEgaW4gdGhlIHN0cnVjdHVyZSBleHBlY3RlZCBieSB0aGUgcnVsZSBlbmdpbmVcbiAgICBjb25zdCByZXR1cm5EYXRhID0ge1xuICAgICAgaWQ6IHJldHVybkl0ZW0uaWQsXG4gICAgICBjdXN0b21lcklkOiByZXR1cm5JdGVtLmN1c3RvbWVySWQsXG4gICAgICBjdXN0b21lck5hbWU6IHJldHVybkl0ZW0uY3VzdG9tZXJOYW1lLFxuICAgICAgcmV0dXJuRnJlcXVlbmN5OiByZXR1cm5JdGVtLnJldHVybkZyZXF1ZW5jeSB8fCAnTm9ybWFsJyxcbiAgICAgIHB1cmNoYXNlRGF0ZTogcmV0dXJuSXRlbS5kYXRlUHVyY2hhc2VkLFxuICAgICAgcmV0dXJuRGF0ZTogcmV0dXJuSXRlbS5kYXRlUmV0dXJuZWQsXG4gICAgICBpdGVtQ29uZGl0aW9uOiByZXR1cm5JdGVtLml0ZW1zWzBdLmNvbmRpdGlvbj8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnbmV3JykgPyAndW51c2VkJyA6ICd1c2VkJyxcbiAgICAgIG9yaWdpbmFsUGFja2FnaW5nOiByZXR1cm5JdGVtLml0ZW1zWzBdLmNvbmRpdGlvbj8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcygndGFnJykgPyB0cnVlIDogZmFsc2UsXG4gICAgICByZWFzb246IHJldHVybkl0ZW0uaXRlbXNbMF0ucmVhc29uLFxuICAgICAgcmVhc29uRGV0YWlsczogcmV0dXJuSXRlbS5pdGVtc1swXS5yZWFzb25EZXRhaWxzLFxuICAgICAgY3VzdG9tZXJSZXR1cm5zQ291bnQ6IHJldHVybkl0ZW0ucmV0dXJuRnJlcXVlbmN5ID09PSAnSGlnaCcgPyA2IDogMiwgLy8gRXhhbXBsZSBsb2dpY1xuICAgICAgb3JkZXJWYWx1ZTogcmV0dXJuSXRlbS5pdGVtcy5yZWR1Y2UoKHRvdGFsLCBpdGVtKSA9PiB0b3RhbCArIChpdGVtLnByaWNlICogaXRlbS5xdWFudGl0eSksIDApLFxuICAgICAgaXRlbXNDb3VudDogcmV0dXJuSXRlbS5pdGVtcy5sZW5ndGgsXG4gICAgICBjYXRlZ29yaWVzOiBbLi4ubmV3IFNldChyZXR1cm5JdGVtLml0ZW1zLm1hcChpdGVtID0+IGl0ZW0uY2F0ZWdvcnkpKV1cbiAgICB9O1xuICAgIFxuICAgIC8vIEV4ZWN1dGUgdGhlIHJ1bGUgb24gdGhpcyByZXR1cm5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZXhlY3V0ZVJ1bGUocnVsZURlZmluaXRpb24sIHJldHVybkRhdGEpO1xuICAgICAgXG4gICAgICAvLyBDb21iaW5lIG9yaWdpbmFsIHJldHVybiBkYXRhIHdpdGggcnVsZSBwcm9jZXNzaW5nIHJlc3VsdFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmV0dXJuSXRlbSxcbiAgICAgICAgcnVsZVByb2Nlc3NpbmdSZXN1bHQ6IHJlc3VsdC5yZXN1bHQsXG4gICAgICAgIGV4ZWN1dGlvblBhdGg6IHJlc3VsdC5leGVjdXRpb25QYXRoLFxuICAgICAgICBhdXRvUHJvY2Vzc2VkOiByZXN1bHQuaXNDb21wbGV0ZSxcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZXR1cm4gc3RhdHVzIGFuZCBuZXh0IGFjdGlvbnMgYmFzZWQgb24gcnVsZSByZXN1bHRcbiAgICAgICAgc3RhdHVzOiBtYXBSdWxlUmVzdWx0VG9TdGF0dXMocmVzdWx0LnJlc3VsdCwgcmV0dXJuSXRlbS5zdGF0dXMpLFxuICAgICAgICBuZXh0QWN0aW9uOiBtYXBSdWxlUmVzdWx0VG9OZXh0QWN0aW9uKHJlc3VsdC5yZXN1bHQsIHJldHVybkl0ZW0ubmV4dEFjdGlvbilcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgcmV0dXJuICR7cmV0dXJuSXRlbS5pZH06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmV0dXJuSXRlbSxcbiAgICAgICAgcnVsZVByb2Nlc3NpbmdSZXN1bHQ6ICdFUlJPUicsXG4gICAgICAgIGV4ZWN1dGlvblBhdGg6IFtdLFxuICAgICAgICBhdXRvUHJvY2Vzc2VkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBcbiAgLy8gR2VuZXJhdGUgdXBkYXRlZCBzdGF0aXN0aWNzIGJhc2VkIG9uIHJ1bGUgcHJvY2Vzc2luZ1xuICBjb25zdCB1cGRhdGVkU3RhdGlzdGljcyA9IGdlbmVyYXRlVXBkYXRlZFN0YXRpc3RpY3MoYmFzZVN0YXRpc3RpY3MsIHByb2Nlc3NlZFJldHVybnMpO1xuICBcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzZWRSZXR1cm5zLFxuICAgIHN0YXRpc3RpY3M6IHVwZGF0ZWRTdGF0aXN0aWNzLFxuICAgIGluc2lnaHRzOiBnZW5lcmF0ZUluc2lnaHRzRnJvbVByb2Nlc3NpbmcocHJvY2Vzc2VkUmV0dXJucywgdXBkYXRlZFN0YXRpc3RpY3MpXG4gIH07XG59XG5cbi8qKlxuICogTWFwcyBhIHJ1bGUgcmVzdWx0IHRvIGEgcmV0dXJuIHN0YXR1c1xuICovXG5mdW5jdGlvbiBtYXBSdWxlUmVzdWx0VG9TdGF0dXMocnVsZVJlc3VsdCwgY3VycmVudFN0YXR1cykge1xuICBzd2l0Y2ggKHJ1bGVSZXN1bHQpIHtcbiAgICBjYXNlICdBUFBST1ZFRCc6XG4gICAgICByZXR1cm4gJ1Byb2Nlc3NlZCc7XG4gICAgY2FzZSAnUkVKRUNURUQnOlxuICAgICAgcmV0dXJuICdSZWplY3RlZCc7XG4gICAgY2FzZSAnTUFOVUFMX1JFVklFVyc6XG4gICAgICByZXR1cm4gJ1VuZGVyIFJldmlldyc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjdXJyZW50U3RhdHVzO1xuICB9XG59XG5cbi8qKlxuICogTWFwcyBhIHJ1bGUgcmVzdWx0IHRvIGEgbmV4dCBhY3Rpb25cbiAqL1xuLyoqXG4gKiBNYXBzIGEgcnVsZSByZXN1bHQgdG8gYSBuZXh0IGFjdGlvblxuICovXG5mdW5jdGlvbiBtYXBSdWxlUmVzdWx0VG9OZXh0QWN0aW9uKHJ1bGVSZXN1bHQsIGN1cnJlbnROZXh0QWN0aW9uLCByZXR1cm5JdGVtKSB7XG4gIGlmIChydWxlUmVzdWx0LnN0YXJ0c1dpdGgoJ09VVENPTUVfJykpIHtcbiAgICByZXR1cm4gcnVsZVJlc3VsdC5yZXBsYWNlKCdPVVRDT01FXycsICcnKTtcbiAgfVxuICBcbiAgc3dpdGNoIChydWxlUmVzdWx0KSB7XG4gICAgY2FzZSAnQVBQUk9WRUQnOlxuICAgICAgLy8gQ2hlY2sgdGhlIGNvbmRpdGlvbiBhbmQgYXNzaWduIHRvIFJlc2FsZSBvciBSZWZ1bmQgUHJvY2VzcyBiYXNlZCBvbiBjb25kaXRpb25cbiAgICAgIGlmIChyZXR1cm5JdGVtICYmIHJldHVybkl0ZW0uaXRlbXMgJiYgcmV0dXJuSXRlbS5pdGVtc1swXSAmJiBcbiAgICAgICAgICAocmV0dXJuSXRlbS5pdGVtc1swXS5jb25kaXRpb24gPT09ICdMaWtlIE5ldycgfHwgXG4gICAgICAgICAgIHJldHVybkl0ZW0uaXRlbXNbMF0uY29uZGl0aW9uPy5pbmNsdWRlcygnTmV3JykpKSB7XG4gICAgICAgIHJldHVybiAnUmVzYWxlJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnUmVmdW5kIFByb2Nlc3MnO1xuICAgIGNhc2UgJ1JFSkVDVEVEJzpcbiAgICAgIHJldHVybiAnUmV0dXJuIHRvIEN1c3RvbWVyJztcbiAgICBjYXNlICdNQU5VQUxfUkVWSUVXJzpcbiAgICAgIHJldHVybiAnUXVhbGl0eSBBc3Nlc3NtZW50JztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGN1cnJlbnROZXh0QWN0aW9uO1xuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHVwZGF0ZWQgc3RhdGlzdGljcyBiYXNlZCBvbiBydWxlIHByb2Nlc3NpbmcgcmVzdWx0c1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVVwZGF0ZWRTdGF0aXN0aWNzKGJhc2VTdGF0aXN0aWNzLCBwcm9jZXNzZWRSZXR1cm5zKSB7XG4gIC8vIENsb25lIHRoZSBiYXNlIHN0YXRpc3RpY3NcbiAgY29uc3Qgc3RhdGlzdGljcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYmFzZVN0YXRpc3RpY3MpKTtcbiAgXG4gIC8vIFVwZGF0ZSB0aGUgc3RhdGlzdGljcyBiYXNlZCBvbiBydWxlIHByb2Nlc3NpbmdcbiAgc3RhdGlzdGljcy5vdmVyYWxsLmFwcHJvdmVkID0gcHJvY2Vzc2VkUmV0dXJucy5maWx0ZXIociA9PiBcbiAgICByLnJ1bGVQcm9jZXNzaW5nUmVzdWx0ID09PSAnQVBQUk9WRUQnIHx8IHIuc3RhdHVzID09PSAnUHJvY2Vzc2VkJ1xuICApLmxlbmd0aDtcbiAgXG4gIHN0YXRpc3RpY3Mub3ZlcmFsbC5kZW5pZWQgPSBwcm9jZXNzZWRSZXR1cm5zLmZpbHRlcihyID0+IFxuICAgIHIucnVsZVByb2Nlc3NpbmdSZXN1bHQgPT09ICdSRUpFQ1RFRCcgfHwgci5zdGF0dXMgPT09ICdSZWplY3RlZCdcbiAgKS5sZW5ndGg7XG4gIFxuICBzdGF0aXN0aWNzLm92ZXJhbGwucGVuZGluZyA9IHByb2Nlc3NlZFJldHVybnMuZmlsdGVyKHIgPT4gXG4gICAgci5ydWxlUHJvY2Vzc2luZ1Jlc3VsdCA9PT0gJ01BTlVBTF9SRVZJRVcnIHx8IHIuc3RhdHVzID09PSAnVW5kZXIgUmV2aWV3JyB8fCByLnN0YXR1cyA9PT0gJ0luIFByb2Nlc3MnXG4gICkubGVuZ3RoO1xuICBcbiAgLy8gQ2FsY3VsYXRlIHRoZSBmcmF1ZCBzdXNwZWN0ZWQgdmFsdWVcbiAgc3RhdGlzdGljcy5vdmVyYWxsLmZyYXVkU3VzcGVjdGVkID0gcHJvY2Vzc2VkUmV0dXJucy5maWx0ZXIociA9PiBcbiAgICByLmZsYWcgPT09ICdGcmVxdWVudCByZXR1cm5lcicgfHwgci5yZXR1cm5GcmVxdWVuY3kgPT09ICdIaWdoJyB8fCAoci5yaXNrU2NvcmUgJiYgci5yaXNrU2NvcmUgPiA1MClcbiAgKS5sZW5ndGg7XG4gIFxuICAvLyBVcGRhdGUgYnkgcHJvY2Vzc2luZyBzdGF0dXNcbiAgc3RhdGlzdGljcy5ieVByb2Nlc3NpbmdTdGF0dXMgPSBbXG4gICAge1xuICAgICAgc3RhdHVzOiBcIlJlZnVuZGVkXCIsXG4gICAgICBjb3VudDogcHJvY2Vzc2VkUmV0dXJucy5maWx0ZXIociA9PiByLnJ1bGVQcm9jZXNzaW5nUmVzdWx0ID09PSAnQVBQUk9WRUQnIHx8IHIuc3RhdHVzID09PSAnUHJvY2Vzc2VkJykubGVuZ3RoLFxuICAgICAgcGVyY2VudGFnZTogTWF0aC5yb3VuZCgocHJvY2Vzc2VkUmV0dXJucy5maWx0ZXIociA9PiByLnJ1bGVQcm9jZXNzaW5nUmVzdWx0ID09PSAnQVBQUk9WRUQnIHx8IHIuc3RhdHVzID09PSAnUHJvY2Vzc2VkJykubGVuZ3RoIC8gcHJvY2Vzc2VkUmV0dXJucy5sZW5ndGgpICogMTAwKVxuICAgIH0sXG4gICAge1xuICAgICAgc3RhdHVzOiBcIlJlc2FsZVwiLFxuICAgICAgY291bnQ6IHByb2Nlc3NlZFJldHVybnMuZmlsdGVyKHIgPT4gci5uZXh0QWN0aW9uID09PSAnUmVzYWxlJykubGVuZ3RoLFxuICAgICAgcGVyY2VudGFnZTogTWF0aC5yb3VuZCgocHJvY2Vzc2VkUmV0dXJucy5maWx0ZXIociA9PiByLm5leHRBY3Rpb24gPT09ICdSZXNhbGUnKS5sZW5ndGggLyBwcm9jZXNzZWRSZXR1cm5zLmxlbmd0aCkgKiAxMDApXG4gICAgfSxcbiAgICB7XG4gICAgICBzdGF0dXM6IFwiUmVmdXJiaXNobWVudFwiLFxuICAgICAgY291bnQ6IHByb2Nlc3NlZFJldHVybnMuZmlsdGVyKHIgPT4gci5uZXh0QWN0aW9uID09PSAnUmVmdXJiaXNobWVudCcpLmxlbmd0aCxcbiAgICAgIHBlcmNlbnRhZ2U6IE1hdGgucm91bmQoKHByb2Nlc3NlZFJldHVybnMuZmlsdGVyKHIgPT4gci5uZXh0QWN0aW9uID09PSAnUmVmdXJiaXNobWVudCcpLmxlbmd0aCAvIHByb2Nlc3NlZFJldHVybnMubGVuZ3RoKSAqIDEwMClcbiAgICB9LFxuICAgIHtcbiAgICAgIHN0YXR1czogXCJEYW1hZ2VkL1dyaXRlLW9mZlwiLFxuICAgICAgY291bnQ6IHByb2Nlc3NlZFJldHVybnMuZmlsdGVyKHIgPT4gci5uZXh0QWN0aW9uID09PSAnUXVhbGl0eSBBc3Nlc3NtZW50JykubGVuZ3RoLFxuICAgICAgcGVyY2VudGFnZTogTWF0aC5yb3VuZCgocHJvY2Vzc2VkUmV0dXJucy5maWx0ZXIociA9PiByLm5leHRBY3Rpb24gPT09ICdRdWFsaXR5IEFzc2Vzc21lbnQnKS5sZW5ndGggLyBwcm9jZXNzZWRSZXR1cm5zLmxlbmd0aCkgKiAxMDApXG4gICAgfVxuICBdO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGF1dG8tcHJvY2Vzc2luZyBlZmZlY3RpdmVuZXNzXG4gIGNvbnN0IGF1dG9tYXRpY2FsbHlQcm9jZXNzZWQgPSBwcm9jZXNzZWRSZXR1cm5zLmZpbHRlcihyID0+IHIuYXV0b1Byb2Nlc3NlZCkubGVuZ3RoO1xuICBzdGF0aXN0aWNzLmF1dG9tYXRpb25NZXRyaWNzID0ge1xuICAgIGF1dG9tYXRpY2FsbHlQcm9jZXNzZWQsXG4gICAgYXV0b21hdGlvblJhdGU6IE1hdGgucm91bmQoKGF1dG9tYXRpY2FsbHlQcm9jZXNzZWQgLyBwcm9jZXNzZWRSZXR1cm5zLmxlbmd0aCkgKiAxMDApLFxuICAgIG1hbnVhbFJldmlld1JhdGU6IE1hdGgucm91bmQoKHByb2Nlc3NlZFJldHVybnMuZmlsdGVyKHIgPT4gci5ydWxlUHJvY2Vzc2luZ1Jlc3VsdCA9PT0gJ01BTlVBTF9SRVZJRVcnKS5sZW5ndGggLyBwcm9jZXNzZWRSZXR1cm5zLmxlbmd0aCkgKiAxMDApLFxuICAgIGF2ZXJhZ2VQYXRoTGVuZ3RoOiBNYXRoLnJvdW5kKHByb2Nlc3NlZFJldHVybnMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIChyLmV4ZWN1dGlvblBhdGg/Lmxlbmd0aCB8fCAwKSwgMCkgLyBwcm9jZXNzZWRSZXR1cm5zLmxlbmd0aClcbiAgfTtcbiAgXG4gIHJldHVybiBzdGF0aXN0aWNzO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBpbnNpZ2h0cyBiYXNlZCBvbiBydWxlIHByb2Nlc3NpbmdcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVJbnNpZ2h0c0Zyb21Qcm9jZXNzaW5nKHByb2Nlc3NlZFJldHVybnMsIHN0YXRpc3RpY3MpIHtcbiAgY29uc3QgaW5zaWdodHMgPSBbXTtcbiAgXG4gIC8vIENoZWNrIGZvciBoaWdoIGF1dG9tYXRpb24gb3Bwb3J0dW5pdGllc1xuICBpZiAoc3RhdGlzdGljcy5hdXRvbWF0aW9uTWV0cmljcy5hdXRvbWF0aW9uUmF0ZSA8IDcwKSB7XG4gICAgaW5zaWdodHMucHVzaCh7XG4gICAgICB0eXBlOiBcInRyZW5kXCIsXG4gICAgICB0aXRsZTogXCJBdXRvbWF0aW9uIE9wcG9ydHVuaXR5XCIsXG4gICAgICBkZXNjcmlwdGlvbjogYEN1cnJlbnQgYXV0b21hdGlvbiByYXRlIGlzICR7c3RhdGlzdGljcy5hdXRvbWF0aW9uTWV0cmljcy5hdXRvbWF0aW9uUmF0ZX0lLiBDb25zaWRlciBhZGRpdGlvbmFsIHJ1bGUgcmVmaW5lbWVudHMuYCxcbiAgICAgIHJlY29tbWVuZGF0aW9uczogW1xuICAgICAgICBcIkFkZCBtb3JlIGNvbmRpdGlvbiBibG9ja3MgdG8geW91ciBydWxlIGZsb3dcIixcbiAgICAgICAgXCJSZWZpbmUgZXhpc3RpbmcgY29uZGl0aW9ucyB0byBiZSBtb3JlIHNwZWNpZmljXCIsXG4gICAgICAgIFwiQ3JlYXRlIHNlcGFyYXRlIHJ1bGVzIGZvciBkaWZmZXJlbnQgcHJvZHVjdCBjYXRlZ29yaWVzXCJcbiAgICAgIF0sXG4gICAgICBwcmlvcml0eTogXCJNZWRpdW1cIixcbiAgICAgIHBvdGVudGlhbEltcGFjdDogXCJSZWR1Y2VkIHByb2Nlc3NpbmcgY29zdHNcIlxuICAgIH0pO1xuICB9XG4gIFxuICAvLyBDaGVjayBmb3IgaGlnaCBtYW51YWwgcmV2aWV3IHJhdGVcbiAgaWYgKHN0YXRpc3RpY3MuYXV0b21hdGlvbk1ldHJpY3MubWFudWFsUmV2aWV3UmF0ZSA+IDMwKSB7XG4gICAgaW5zaWdodHMucHVzaCh7XG4gICAgICB0eXBlOiBcImludmVudG9yeVwiLFxuICAgICAgdGl0bGU6IFwiSGlnaCBNYW51YWwgUmV2aWV3IFJhdGVcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBgJHtzdGF0aXN0aWNzLmF1dG9tYXRpb25NZXRyaWNzLm1hbnVhbFJldmlld1JhdGV9JSBvZiByZXR1cm5zIGFyZSBiZWluZyBzZW50IGZvciBtYW51YWwgcmV2aWV3LiBUaGlzIGluY3JlYXNlcyBwcm9jZXNzaW5nIHRpbWUuYCxcbiAgICAgIHJlY29tbWVuZGF0aW9uczogW1xuICAgICAgICBcIlJlZmluZSBydWxlIGNvbmRpdGlvbnMgdG8gcmVkdWNlIG1hbnVhbCByZXZpZXdzXCIsXG4gICAgICAgIFwiQWRkIG1vcmUgc3BlY2lmaWMgcnVsZXMgZm9yIGNvbW1vbiByZXR1cm4gc2NlbmFyaW9zXCJcbiAgICAgIF0sXG4gICAgICBwcmlvcml0eTogXCJIaWdoXCIsXG4gICAgICBwb3RlbnRpYWxJbXBhY3Q6IFwiRmFzdGVyIHByb2Nlc3NpbmcsIGltcHJvdmVkIGN1c3RvbWVyIHNhdGlzZmFjdGlvblwiXG4gICAgfSk7XG4gIH1cbiAgXG4gIC8vIENoZWNrIGZvciByZXR1cm4gcmVhc29ucyB0aGF0IG1pZ2h0IG5lZWQgYXR0ZW50aW9uXG4gIGNvbnN0IHJlYXNvbkNvdW50cyA9IHt9O1xuICBwcm9jZXNzZWRSZXR1cm5zLmZvckVhY2gociA9PiB7XG4gICAgY29uc3QgcmVhc29uID0gci5pdGVtc1swXS5yZWFzb247XG4gICAgcmVhc29uQ291bnRzW3JlYXNvbl0gPSAocmVhc29uQ291bnRzW3JlYXNvbl0gfHwgMCkgKyAxO1xuICB9KTtcbiAgXG4gIGNvbnN0IHRvcFJlYXNvbiA9IE9iamVjdC5lbnRyaWVzKHJlYXNvbkNvdW50cykuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pWzBdO1xuICBpZiAodG9wUmVhc29uICYmIHRvcFJlYXNvblsxXSA+IHByb2Nlc3NlZFJldHVybnMubGVuZ3RoICogMC4zKSB7XG4gICAgaW5zaWdodHMucHVzaCh7XG4gICAgICB0eXBlOiBcImN1c3RvbWVyXCIsXG4gICAgICB0aXRsZTogYEhpZ2ggUmV0dXJuIFJhdGU6IFwiJHt0b3BSZWFzb25bMF19XCJgLFxuICAgICAgZGVzY3JpcHRpb246IGAke01hdGgucm91bmQoKHRvcFJlYXNvblsxXSAvIHByb2Nlc3NlZFJldHVybnMubGVuZ3RoKSAqIDEwMCl9JSBvZiByZXR1cm5zIGNpdGUgXCIke3RvcFJlYXNvblswXX1cIiBhcyB0aGUgcmVhc29uLmAsXG4gICAgICByZWNvbW1lbmRhdGlvbnM6IFtcbiAgICAgICAgXCJSZXZpZXcgcHJvZHVjdCBkZXNjcmlwdGlvbnMgYW5kIHNpemluZyBpbmZvcm1hdGlvblwiLFxuICAgICAgICBcIkNvbnNpZGVyIGFkanVzdGluZyBwcm9kdWN0IGRlc2lnbiBvciBmZWF0dXJlc1wiLFxuICAgICAgICBcIkFkZCBtb3JlIGRldGFpbGVkIHByb2R1Y3QgaW5mb3JtYXRpb24gdG8gcmVkdWNlIGV4cGVjdGF0aW9uIG1pc21hdGNoXCJcbiAgICAgIF0sXG4gICAgICBwcmlvcml0eTogXCJIaWdoXCIsXG4gICAgICBwb3RlbnRpYWxJbXBhY3Q6IFwiUmVkdWNlZCByZXR1cm4gcmF0ZSwgaW5jcmVhc2VkIGN1c3RvbWVyIHNhdGlzZmFjdGlvblwiXG4gICAgfSk7XG4gIH1cbiAgXG4gIC8vIElmIHRoZXJlIGFyZSBtYW55IGZyZXF1ZW50IHJldHVybmVycywgYWRkIGFuIGluc2lnaHRcbiAgY29uc3QgZnJlcXVlbnRSZXR1cm5lcnMgPSBwcm9jZXNzZWRSZXR1cm5zLmZpbHRlcihyID0+IHIucmV0dXJuRnJlcXVlbmN5ID09PSAnSGlnaCcgfHwgci5mbGFnID09PSAnRnJlcXVlbnQgcmV0dXJuZXInKS5sZW5ndGg7XG4gIGlmIChmcmVxdWVudFJldHVybmVycyA+IHByb2Nlc3NlZFJldHVybnMubGVuZ3RoICogMC4xNSkge1xuICAgIGluc2lnaHRzLnB1c2goe1xuICAgICAgdHlwZTogXCJmcmF1ZFwiLFxuICAgICAgdGl0bGU6IFwiSGlnaCBSYXRlIG9mIEZyZXF1ZW50IFJldHVybmVyc1wiLFxuICAgICAgZGVzY3JpcHRpb246IGAke01hdGgucm91bmQoKGZyZXF1ZW50UmV0dXJuZXJzIC8gcHJvY2Vzc2VkUmV0dXJucy5sZW5ndGgpICogMTAwKX0lIG9mIHJldHVybnMgYXJlIGZyb20gZnJlcXVlbnQgcmV0dXJuZXJzLmAsXG4gICAgICByZWNvbW1lbmRhdGlvbnM6IFtcbiAgICAgICAgXCJSZXZpZXcgY3VycmVudCByZXR1cm4gcG9saWN5IGxpbWl0c1wiLFxuICAgICAgICBcIkNvbnNpZGVyIGltcGxlbWVudGluZyBhIHJldHVybiBmZWUgZm9yIGV4Y2Vzc2l2ZSByZXR1cm5zXCIsXG4gICAgICAgIFwiQ3JlYXRlIHNwZWNpYWwgcnVsZXMgZm9yIGhhbmRsaW5nIGZyZXF1ZW50IHJldHVybmVyc1wiXG4gICAgICBdLFxuICAgICAgcHJpb3JpdHk6IFwiTWVkaXVtXCIsXG4gICAgICBwb3RlbnRpYWxJbXBhY3Q6IFwiUmVkdWNlZCByZXR1cm4gYWJ1c2UsIGJldHRlciBwcm9maXQgbWFyZ2luc1wiXG4gICAgfSk7XG4gIH1cbiAgXG4gIHJldHVybiBpbnNpZ2h0cztcbn1cblxuLyoqXG4gKiBFeGFtcGxlIHVzYWdlOlxuICogXG4gKiAvLyBMb2FkIHlvdXIgZXhwb3J0ZWQgcnVsZSBkZWZpbml0aW9uIEpTT05cbiAqIGltcG9ydCBteVJ1bGVEZWZpbml0aW9uIGZyb20gJy4vbXlfcmV0dXJuX3BvbGljeV9ydWxlLmpzb24nO1xuICogXG4gKiAvLyBQcm9jZXNzIGFsbCByZXR1cm5zIHVzaW5nIHRoaXMgcnVsZVxuICogY29uc3QgeyBwcm9jZXNzZWRSZXR1cm5zLCBzdGF0aXN0aWNzLCBpbnNpZ2h0cyB9ID0gYXdhaXQgcHJvY2Vzc1JldHVybnNXaXRoUnVsZShteVJ1bGVEZWZpbml0aW9uKTtcbiAqIFxuICogLy8gTm93IHlvdSBjYW4gdXBkYXRlIHlvdXIgZGFzaGJvYXJkIHdpdGggdGhpcyBkYXRhXG4gKiB1cGRhdGVEYXNoYm9hcmQocHJvY2Vzc2VkUmV0dXJucywgc3RhdGlzdGljcywgaW5zaWdodHMpO1xuICovIl0sIm5hbWVzIjpbImV4ZWN1dGVSdWxlIiwiZ2V0UmVjZW50UmV0dXJucyIsImdldFJldHVyblN0YXRpc3RpY3MiLCJwcm9jZXNzUmV0dXJuc1dpdGhSdWxlIiwicnVsZURlZmluaXRpb24iLCJyZXR1cm5zIiwiYmFzZVN0YXRpc3RpY3MiLCJwcm9jZXNzZWRSZXR1cm5zIiwibWFwIiwicmV0dXJuSXRlbSIsInJldHVybkRhdGEiLCJpZCIsImN1c3RvbWVySWQiLCJjdXN0b21lck5hbWUiLCJyZXR1cm5GcmVxdWVuY3kiLCJwdXJjaGFzZURhdGUiLCJkYXRlUHVyY2hhc2VkIiwicmV0dXJuRGF0ZSIsImRhdGVSZXR1cm5lZCIsIml0ZW1Db25kaXRpb24iLCJpdGVtcyIsImNvbmRpdGlvbiIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJvcmlnaW5hbFBhY2thZ2luZyIsInJlYXNvbiIsInJlYXNvbkRldGFpbHMiLCJjdXN0b21lclJldHVybnNDb3VudCIsIm9yZGVyVmFsdWUiLCJyZWR1Y2UiLCJ0b3RhbCIsIml0ZW0iLCJwcmljZSIsInF1YW50aXR5IiwiaXRlbXNDb3VudCIsImxlbmd0aCIsImNhdGVnb3JpZXMiLCJTZXQiLCJjYXRlZ29yeSIsInJlc3VsdCIsInJ1bGVQcm9jZXNzaW5nUmVzdWx0IiwiZXhlY3V0aW9uUGF0aCIsImF1dG9Qcm9jZXNzZWQiLCJpc0NvbXBsZXRlIiwic3RhdHVzIiwibWFwUnVsZVJlc3VsdFRvU3RhdHVzIiwibmV4dEFjdGlvbiIsIm1hcFJ1bGVSZXN1bHRUb05leHRBY3Rpb24iLCJlcnJvciIsImNvbnNvbGUiLCJ1cGRhdGVkU3RhdGlzdGljcyIsImdlbmVyYXRlVXBkYXRlZFN0YXRpc3RpY3MiLCJzdGF0aXN0aWNzIiwiaW5zaWdodHMiLCJnZW5lcmF0ZUluc2lnaHRzRnJvbVByb2Nlc3NpbmciLCJydWxlUmVzdWx0IiwiY3VycmVudFN0YXR1cyIsImN1cnJlbnROZXh0QWN0aW9uIiwic3RhcnRzV2l0aCIsInJlcGxhY2UiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJvdmVyYWxsIiwiYXBwcm92ZWQiLCJmaWx0ZXIiLCJyIiwiZGVuaWVkIiwicGVuZGluZyIsImZyYXVkU3VzcGVjdGVkIiwiZmxhZyIsInJpc2tTY29yZSIsImJ5UHJvY2Vzc2luZ1N0YXR1cyIsImNvdW50IiwicGVyY2VudGFnZSIsIk1hdGgiLCJyb3VuZCIsImF1dG9tYXRpY2FsbHlQcm9jZXNzZWQiLCJhdXRvbWF0aW9uTWV0cmljcyIsImF1dG9tYXRpb25SYXRlIiwibWFudWFsUmV2aWV3UmF0ZSIsImF2ZXJhZ2VQYXRoTGVuZ3RoIiwic3VtIiwicHVzaCIsInR5cGUiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwicmVjb21tZW5kYXRpb25zIiwicHJpb3JpdHkiLCJwb3RlbnRpYWxJbXBhY3QiLCJyZWFzb25Db3VudHMiLCJmb3JFYWNoIiwidG9wUmVhc29uIiwiT2JqZWN0IiwiZW50cmllcyIsInNvcnQiLCJhIiwiYiIsImZyZXF1ZW50UmV0dXJuZXJzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/services/returns-processor.js\n"));

/***/ })

});